#!/usr/bin/env python3
"""
shimlink: A symlink-based binary manager that downloads and manages binaries on demand.

When invoked through a symlink, shimlink determines the target binary name from the
symlink filename, validates the binary exists with correct checksum, downloads if needed,
then exec's the target binary with all arguments and environment passed through.
"""

import argparse
import gzip
import hashlib
import json
import os
import platform
import shutil
import sys
import tarfile
import tempfile
import urllib.request
import zipfile
from pathlib import Path


def get_platform() -> str:
    """Get the current platform identifier."""
    system = platform.system().lower()
    machine = platform.machine().lower()

    # Normalize architecture names
    if machine in ("aarch64", "arm64"):
        machine = "arm64"

    return f"{system}-{machine}"


def calculate_sha256(filepath: Path) -> str:
    """Calculate SHA256 hash of a file."""
    hash_sha256 = hashlib.sha256()
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_sha256.update(chunk)
    return hash_sha256.hexdigest()


def get_config_dir() -> Path:
    """Get the shimlink configuration directory."""
    return Path.home() / ".config" / "shimlink"


def get_config_path() -> Path:
    """Get the path to general shimlink configuration file."""
    return get_config_dir() / "shimlink.json"


def get_platform_config_path() -> Path:
    """Get the path to platform-specific shimlink configuration file."""
    return get_config_dir() / f"{get_platform()}.json"


def get_bin_dir(binary_name: str = None) -> Path:
    """Get the directory where shimlink stores managed binaries."""
    if binary_name:
        return Path.home() / ".local" / "share" / "shimlink" / binary_name
    return Path.home() / ".local" / "share" / "shimlink"


def load_config() -> dict:
    """Load shimlink configuration from both general and platform-specific files."""
    config_dir = get_config_dir()
    general_config_path = get_config_path()
    platform_config_path = get_platform_config_path()
    
    # Check if config directory exists
    if not config_dir.exists():
        print(f"shimlink: configuration directory not found at {config_dir}", file=sys.stderr)
        print("shimlink: create ~/.config/shimlink/ with shimlink.json and <platform>.json files", file=sys.stderr)
        sys.exit(1)
    
    # Load general config (may be empty)
    general_config = {}
    if general_config_path.exists():
        with open(general_config_path, 'r') as f:
            general_config = json.load(f)
    
    # Load platform-specific config
    if not platform_config_path.exists():
        print(f"shimlink: platform configuration file not found at {platform_config_path}", file=sys.stderr)
        print(f"shimlink: create ~/.config/shimlink/{get_platform()}.json with binary configurations", file=sys.stderr)
        sys.exit(1)
    
    with open(platform_config_path, 'r') as f:
        platform_config = json.load(f)
    
    # Merge configs: platform-specific takes precedence
    merged_config = general_config.copy()
    if 'binaries' in platform_config:
        if 'binaries' not in merged_config:
            merged_config['binaries'] = {}
        merged_config['binaries'].update(platform_config['binaries'])
    if 'aliases' in platform_config:
        if 'aliases' not in merged_config:
            merged_config['aliases'] = {}
        merged_config['aliases'].update(platform_config['aliases'])

    return merged_config


def download_file(url: str, dest_path: Path) -> None:
    """Download a file from URL to destination path."""
    print(f"shimlink: downloading {url}", file=sys.stderr)

    request = urllib.request.Request(url)
    request.add_header("User-Agent", "shimlink/1.0")

    with urllib.request.urlopen(request) as response:
        with open(dest_path, "wb") as f:
            shutil.copyfileobj(response, f)


def extract_archive(archive_path: Path, extract_to: Path, executable_path: str = None) -> Path:
    """Extract archive contents and return path to executable."""
    if archive_path.suffix == ".zip":
        with zipfile.ZipFile(archive_path, "r") as zf:
            zf.extractall(extract_to)
    elif archive_path.name.endswith((".tar.gz", ".tgz")):
        with tarfile.open(archive_path, "r:gz") as tf:
            tf.extractall(extract_to)
    elif archive_path.suffix == ".gz" and not archive_path.name.endswith(".tar.gz"):
        # Single file gzip compression - extract to specified path
        if not executable_path:
            raise ValueError("executable_path required for single file gzip")
        output_path = extract_to / executable_path
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with gzip.open(archive_path, "rb") as gz_file:
            with open(output_path, "wb") as out_file:
                shutil.copyfileobj(gz_file, out_file)
        return output_path
    else:
        raise ValueError(f"Unsupported archive format: {archive_path}")
    
    # For archives, locate the executable
    if executable_path:
        return extract_to / executable_path
    else:
        # No executable_path specified, assume direct binary download
        return archive_path


def needs_download(binary_name: str, config: dict) -> bool:
    """Check if binary needs to be downloaded or updated."""
    binary_config = config["binaries"].get(binary_name)
    if not binary_config:
        print(f"shimlink: no configuration found for {binary_name}", file=sys.stderr)
        return False

    # Get the path to the executable
    bin_dir = get_bin_dir(binary_name)
    executable_path = binary_config.get("executable_path")
    if executable_path:
        binary_path = bin_dir / executable_path
    else:
        # Direct binary download, executable is at root of binary directory
        binary_path = bin_dir / binary_name

    if not binary_path.exists():
        return True

    sha256_value = binary_config.get("sha256")
    if not sha256_value or sha256_value == "SKIP_CHECKSUM":
        # No checksum verification, assume binary is fine
        return False

    # Verify checksum
    expected_sha256 = binary_config["sha256"]
    actual_sha256 = calculate_sha256(binary_path)

    if actual_sha256 != expected_sha256:
        print(f"shimlink: checksum mismatch for {binary_name}, will re-download", file=sys.stderr)
        return True

    return False


def update_config_checksum(binary_name: str, config: dict, new_checksum: str) -> None:
    """Update the checksum in the platform-specific configuration file."""
    config["binaries"][binary_name]["sha256"] = new_checksum
    
    # Write to platform-specific config file
    platform_config_path = get_platform_config_path()
    with open(platform_config_path, 'w') as f:
        json.dump(config, f, indent=2)
    
    print(f"shimlink: updated checksum for {binary_name} to {new_checksum}", file=sys.stderr)


def download_binary(binary_name: str, config: dict, force: bool = False) -> bool:
    """Download and install a binary. Returns True if successful."""
    binary_config = config["binaries"].get(binary_name)
    if not binary_config:
        print(f"shimlink: no configuration found for {binary_name}", file=sys.stderr)
        return False

    url = binary_config["url"]
    expected_sha256 = binary_config.get("sha256", "SKIP_CHECKSUM")
    executable_path = binary_config.get("executable_path")

    bin_dir = get_bin_dir(binary_name)
    bin_dir.mkdir(parents=True, exist_ok=True)

    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)

        # Download
        download_name = Path(url).name
        download_path = temp_path / download_name

        try:
            download_file(url, download_path)
        except Exception as e:
            print(f"shimlink: failed to download {binary_name}: {e}", file=sys.stderr)
            return False

        # Extract or copy binary
        if executable_path:
            try:
                # Extract to temporary location first
                extract_temp = temp_path / "extracted"
                extract_temp.mkdir()
                extracted_binary = extract_archive(download_path, extract_temp, executable_path)
            except Exception as e:
                print(f"shimlink: failed to extract {binary_name}: {e}", file=sys.stderr)
                return False
        else:
            # Direct binary download
            extracted_binary = download_path
            extract_temp = temp_path

        # Make executable
        if extracted_binary.exists():
            extracted_binary.chmod(0o755)

        # Calculate actual checksum for verification or update
        actual_sha256 = calculate_sha256(extracted_binary)
        
        # Handle checksum verification and updates
        if force:
            # Force mode: always update config with actual checksum
            update_config_checksum(binary_name, config, actual_sha256)
            print(f"shimlink: force mode - updated checksum for {binary_name}", file=sys.stderr)
        elif expected_sha256 and expected_sha256 != "SKIP_CHECKSUM":
            # Normal mode: verify checksum if provided
            if actual_sha256 != expected_sha256:
                print(f"shimlink: checksum mismatch for {binary_name}", file=sys.stderr)
                print(f"shimlink:   expected: {expected_sha256}", file=sys.stderr)
                print(f"shimlink:   actual:   {actual_sha256}", file=sys.stderr)
                return False

        # Move entire extracted directory to final destination
        # Remove existing directory if it exists
        if bin_dir.exists():
            shutil.rmtree(bin_dir)
        
        if executable_path:
            # Move the entire extracted directory structure
            shutil.move(str(extract_temp), str(bin_dir))
        else:
            # For direct binary downloads, create directory and move binary
            bin_dir.mkdir(parents=True)
            final_path = bin_dir / binary_name
            shutil.move(str(extracted_binary), str(final_path))

        print(f"shimlink: installed {binary_name}", file=sys.stderr)
        
        # Run test command if provided
        test_command = binary_config.get("test_command")
        if test_command:
            # Find the actual executable for testing
            if executable_path:
                test_binary_path = bin_dir / executable_path
            else:
                test_binary_path = bin_dir / binary_name
                
            if test_binary(test_binary_path, test_command):
                print(f"shimlink: {binary_name} test passed", file=sys.stderr)
            else:
                print(f"shimlink: {binary_name} test failed", file=sys.stderr)
        
        return True


def test_binary(binary_path: Path, test_command: str) -> bool:
    """Test a binary using the provided test command. Returns True if test passes."""
    import subprocess
    
    # Replace {binary} placeholder with actual binary path
    cmd = test_command.replace("{binary}", str(binary_path))
    
    try:
        # Run the test command with a timeout
        result = subprocess.run(
            cmd,
            shell=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            timeout=10
        )
        return result.returncode == 0
    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
        return False


def resolve_alias(name: str, config: dict) -> str:
    """Resolve an alias to the actual binary name."""
    aliases = config.get("aliases", {})
    return aliases.get(name, name)


def get_target_name() -> str:
    """Determine the target binary name from how shimlink was invoked."""
    # Get the actual path of the symlink (not resolved)
    invoked_path = Path(sys.argv[0])

    # If invoked directly as shimlink, show help
    if invoked_path.name == "shimlink":
        return "shimlink"

    # Otherwise, use the symlink name as the target
    return invoked_path.name


def exec_binary(binary_name: str, args: list, config: dict) -> None:
    """Execute the target binary with the given arguments."""
    binary_config = config["binaries"].get(binary_name)
    if not binary_config:
        print(f"shimlink: no configuration found for {binary_name}", file=sys.stderr)
        sys.exit(1)

    bin_dir = get_bin_dir(binary_name)
    executable_path = binary_config.get("executable_path")
    
    if executable_path:
        binary_path = bin_dir / executable_path
    else:
        binary_path = bin_dir / binary_name
    
    if not binary_path.exists():
        print(f"shimlink: binary {binary_name} not found at {binary_path}", file=sys.stderr)
        sys.exit(1)
    
    # Execute the binary, replacing the current process
    try:
        os.execve(str(binary_path), [binary_name] + args, os.environ)
    except OSError as e:
        print(f"shimlink: failed to execute {binary_name}: {e}", file=sys.stderr)
        sys.exit(1)


def show_help():
    """Show shimlink help information."""
    print("shimlink: A symlink-based binary manager")
    print()
    print("Usage:")
    print("  shimlink                    # Show this help")
    print("  shimlink -f <binary>        # Force download and update checksum")
    print("  ln -s shimlink <binary>     # Create symlink for managed binary")
    print("  <binary> [args...]          # Execute binary through shimlink")
    print()
    print("Options:")
    print("  -f, --force                 # Skip checksum validation and update config")
    print()
    print("When invoked through a symlink, shimlink automatically downloads")
    print("and manages the target binary, then executes it with all arguments.")
    print()
    print("Aliases can be defined in the 'aliases' section of the config to map")
    print("alternative names to actual binary names (e.g., 'nvim-1' -> 'nvim').")
    print()
    print("Configuration: ~/.config/shimlink/shimlink.json (general)")
    print("               ~/.config/shimlink/<platform>.json (platform-specific)")
    print("Binaries stored: ~/.local/share/shimlink/<binary>/")


def main():
    """Main entry point."""
    target_name = get_target_name()
    
    if target_name == "shimlink":
        # Parse arguments when invoked as shimlink directly
        parser = argparse.ArgumentParser(
            prog="shimlink",
            description="A symlink-based binary manager",
            add_help=False
        )
        parser.add_argument("-f", "--force", action="store_true",
                          help="Force download and update checksum")
        parser.add_argument("-h", "--help", action="store_true",
                          help="Show help")
        parser.add_argument("binary", nargs="?",
                          help="Binary to force download")
        
        args, remaining = parser.parse_known_args()
        
        if args.help or (not args.force and not args.binary):
            show_help()
            return
        
        if args.force:
            if not args.binary:
                print("shimlink: -f requires a binary name", file=sys.stderr)
                sys.exit(1)
            
            # Load configuration
            try:
                config = load_config()
            except Exception as e:
                print(f"shimlink: failed to load configuration: {e}", file=sys.stderr)
                sys.exit(1)
            
            # Force download the specified binary
            if not download_binary(args.binary, config, force=True):
                print(f"shimlink: failed to force download {args.binary}", file=sys.stderr)
                sys.exit(1)
            return
        
        # If we get here, show help
        show_help()
        return
    
    # Load configuration
    try:
        config = load_config()
    except Exception as e:
        print(f"shimlink: failed to load configuration: {e}", file=sys.stderr)
        sys.exit(1)

    # Resolve alias to actual binary name
    actual_binary_name = resolve_alias(target_name, config)

    # Check if we need to download the binary
    if needs_download(actual_binary_name, config):
        if not download_binary(actual_binary_name, config):
            print(f"shimlink: failed to ensure {actual_binary_name} is available", file=sys.stderr)
            sys.exit(1)

    # Execute the target binary with all arguments (excluding argv[0])
    exec_binary(actual_binary_name, sys.argv[1:], config)


if __name__ == "__main__":
    main()