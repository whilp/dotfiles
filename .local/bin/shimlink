#!/usr/bin/env lua
--[[
shimlink: A symlink-based binary manager that downloads and manages binaries on demand.

When invoked through a symlink, shimlink determines the target binary name from the
symlink filename, validates the binary exists with correct checksum, downloads if needed,
then exec's the target binary with all arguments and environment passed through.
]]

local ffi = require("ffi")

-- FFI declarations for system calls
ffi.cdef([[
  typedef struct { long tv_sec; long tv_usec; } timeval;
  int execve(const char *path, char *const argv[], char *const envp[]);
  char *getenv(const char *name);
  int symlink(const char *target, const char *linkpath);
  int unlink(const char *pathname);
  int mkdir(const char *pathname, unsigned int mode);
  int access(const char *pathname, int mode);
  int chmod(const char *pathname, unsigned int mode);
  char *realpath(const char *path, char *resolved_path);

  // uname for platform detection
  struct utsname {
    char sysname[65];
    char nodename[65];
    char release[65];
    char version[65];
    char machine[65];
  };
  int uname(struct utsname *buf);

  // environ for accessing environment variables
  extern char **environ;
]])

-- Helper functions
local function stderr_write(msg)
  io.stderr:write(msg .. "\n")
  io.stderr:flush()
end

local function file_exists(path)
  local f = io.open(path, "r")
  if f then
    f:close()
    return true
  end
  return false
end

local function is_directory(path)
  local ok, err, code = os.rename(path, path)
  if not ok and code == 13 then
    return true
  end
  return ok
end

local function read_file(path)
  local f = io.open(path, "rb")
  if not f then
    return nil
  end
  local content = f:read("*all")
  f:close()
  return content
end

local function write_file(path, content)
  local f = io.open(path, "wb")
  if not f then
    return false
  end
  f:write(content)
  f:close()
  return true
end

local function get_home_dir()
  return os.getenv("HOME") or os.getenv("USERPROFILE")
end

local function path_join(...)
  local parts = { ... }
  return table.concat(parts, "/")
end

local function expand_path(path)
  if path:sub(1, 1) == "~" then
    return get_home_dir() .. path:sub(2)
  end
  return path
end

local function mkdir_p(path)
  local parts = {}
  for part in path:gmatch("[^/]+") do
    table.insert(parts, part)
  end

  local current = path:sub(1, 1) == "/" and "/" or ""
  for _, part in ipairs(parts) do
    current = current .. part
    if not is_directory(current) then
      ffi.C.mkdir(current, tonumber("0755", 8))
    end
    current = current .. "/"
  end
end

local function rm_rf(path)
  if not file_exists(path) and not is_directory(path) then
    return true
  end

  local result = os.execute(string.format("rm -rf %q", path))
  return result == 0 or result == true
end

local function basename(path)
  return path:match("([^/]+)$") or path
end

local function dirname(path)
  local dir = path:match("(.+)/[^/]+$")
  return dir or "."
end

-- Platform detection (using LuaJIT built-ins instead of FFI to avoid segfault)
local function get_platform()
  local system = jit.os:lower()
  local machine = jit.arch:lower()

  -- Normalize system names
  local system_map = {
    osx = "darwin",
  }
  system = system_map[system] or system

  -- Normalize architecture names
  local arch_map = {
    x64 = "x86_64",
    aarch64 = "arm64",
    arm64 = "arm64",
  }
  machine = arch_map[machine] or machine

  return system .. "-" .. machine
end

-- SHA256 calculation
local function calculate_sha256(filepath)
  local handle = io.popen(string.format("shasum -a 256 %q", filepath))
  local result = handle:read("*all")
  handle:close()

  local hash = result:match("^(%x+)")
  return hash
end

-- Configuration paths
local function get_config_dir()
  return path_join(get_home_dir(), ".config", "shimlink")
end

local function get_platform_config_path()
  return path_join(get_config_dir(), get_platform() .. ".lua")
end

local function get_bin_dir(binary_name)
  if binary_name then
    return path_join(get_home_dir(), ".local", "share", "shimlink", binary_name)
  end
  return path_join(get_home_dir(), ".local", "share", "shimlink")
end

-- Configuration loading
local function load_config()
  local config_dir = get_config_dir()
  local platform_config_path = get_platform_config_path()

  -- Check if config directory exists
  if not is_directory(config_dir) then
    stderr_write("shimlink: configuration directory not found at " .. config_dir)
    stderr_write("shimlink: create ~/.config/shimlink/ with <platform>.lua file")
    os.exit(1)
  end

  -- Load platform-specific config
  if not file_exists(platform_config_path) then
    stderr_write("shimlink: platform configuration file not found at " .. platform_config_path)
    stderr_write("shimlink: create ~/.config/shimlink/" .. get_platform() .. ".lua with binary configurations")
    os.exit(1)
  end

  local func, err = loadfile(platform_config_path)
  if not func then
    stderr_write("shimlink: failed to load " .. platform_config_path .. ": " .. tostring(err))
    os.exit(1)
  end

  local ok, config = pcall(func)
  if not ok then
    stderr_write("shimlink: failed to execute " .. platform_config_path .. ": " .. tostring(config))
    os.exit(1)
  end

  if type(config) ~= "table" then
    stderr_write("shimlink: config must return a table, got " .. type(config))
    os.exit(1)
  end

  return config
end

-- Download file
local function download_file(url, dest_path)
  stderr_write("shimlink: downloading " .. url)

  local result = os.execute(string.format("curl -fsSL -A 'shimlink/1.0' -o %q %q", dest_path, url))
  return result == 0 or result == true
end

-- Extract archive
local function extract_archive(archive_path, extract_to, executable_path)
  local archive_name = basename(archive_path)

  if archive_name:match("%.zip$") then
    local result = os.execute(string.format("unzip -q %q -d %q", archive_path, extract_to))
    if not (result == 0 or result == true) then
      return nil, "failed to extract zip"
    end
  elseif archive_name:match("%.tar%.gz$") or archive_name:match("%.tgz$") then
    local result = os.execute(string.format("tar -xzf %q -C %q", archive_path, extract_to))
    if not (result == 0 or result == true) then
      return nil, "failed to extract tar.gz"
    end
  elseif archive_name:match("%.gz$") and not archive_name:match("%.tar%.gz$") then
    -- Single file gzip compression
    if not executable_path then
      return nil, "executable_path required for single file gzip"
    end
    local output_path = path_join(extract_to, executable_path)
    mkdir_p(dirname(output_path))
    local result = os.execute(string.format("gunzip -c %q > %q", archive_path, output_path))
    if not (result == 0 or result == true) then
      return nil, "failed to extract gzip"
    end
    return output_path
  else
    return nil, "unsupported archive format: " .. archive_path
  end

  -- For archives, locate the executable
  if executable_path then
    return path_join(extract_to, executable_path)
  else
    return archive_path
  end
end

-- Check if binary needs download
local function needs_download(binary_name, config)
  local binary_config = config.binaries and config.binaries[binary_name]
  if not binary_config then
    stderr_write("shimlink: no configuration found for " .. binary_name)
    return false
  end

  -- Get the path to the executable
  local bin_dir = get_bin_dir(binary_name)
  local path = binary_config.path
  local binary_path

  if path then
    binary_path = path_join(bin_dir, path)
  else
    binary_path = path_join(bin_dir, binary_name)
  end

  if not file_exists(binary_path) then
    return true
  end

  local expected_sha256 = binary_config.sha256
  if not expected_sha256 then
    return false
  end

  -- Verify checksum
  local actual_sha256 = calculate_sha256(binary_path)

  if actual_sha256 ~= expected_sha256 then
    stderr_write("shimlink: checksum mismatch for " .. binary_name .. ", will re-download")
    return true
  end

  return false
end

-- Update config checksum
local function update_config_checksum(binary_name, config, new_checksum)
  config.binaries[binary_name].sha256 = new_checksum

  -- Write to platform-specific config file using string replacement
  local platform_config_path = get_platform_config_path()
  local content = read_file(platform_config_path)

  if not content then
    stderr_write("shimlink: failed to read " .. platform_config_path)
    return
  end

  -- Pattern to match the sha256 field for this binary
  -- Handles both ["binary-name"] and binary_name key formats
  local pattern = '(%[?"?' .. binary_name:gsub("%-", "%%-") .. '"?%]?%s*=%s*%{.-)sha256%s*=%s*"([^"]*)"'
  local replaced = false

  content = content:gsub(pattern, function(before, old_hash)
    replaced = true
    return before .. 'sha256 = "' .. new_checksum .. '"'
  end)

  if not replaced then
    stderr_write("shimlink: warning: could not find sha256 field for " .. binary_name .. " in config")
    return
  end

  write_file(platform_config_path, content)
  stderr_write("shimlink: updated checksum for " .. binary_name .. " to " .. new_checksum)
end

-- Create symlink
local function create_symlink(bin_dir, src_path, dest_path, binary_name)
  local source = path_join(bin_dir, src_path)

  if not file_exists(source) then
    stderr_write("shimlink: warning: symlink source does not exist: " .. source)
    return
  end

  local dest = expand_path(dest_path)

  -- Create parent directories if needed
  mkdir_p(dirname(dest))

  -- Remove existing symlink or file
  if file_exists(dest) then
    ffi.C.unlink(dest)
  end

  -- Create the symlink
  local result = ffi.C.symlink(source, dest)
  if result == 0 then
    stderr_write("shimlink: created symlink " .. dest .. " -> " .. source)
  else
    stderr_write("shimlink: warning: failed to create symlink " .. dest)
  end
end

-- Download binary
local function download_binary(binary_name, config, force)
  local binary_config = config.binaries and config.binaries[binary_name]
  if not binary_config then
    stderr_write("shimlink: no configuration found for " .. binary_name)
    return false
  end

  local url = binary_config.url
  local expected_sha256 = binary_config.sha256
  local path = binary_config.path

  local bin_dir = get_bin_dir(binary_name)
  mkdir_p(bin_dir)

  -- Create temporary directory
  local temp_dir = os.tmpname()
  os.remove(temp_dir)
  mkdir_p(temp_dir)

  -- Download
  local download_name = basename(url)
  local download_path = path_join(temp_dir, download_name)

  if not download_file(url, download_path) then
    stderr_write("shimlink: failed to download " .. binary_name)
    rm_rf(temp_dir)
    return false
  end

  -- Extract or copy binary
  local extracted_binary
  local extract_temp

  if path then
    extract_temp = path_join(temp_dir, "extracted")
    mkdir_p(extract_temp)
    local err
    extracted_binary, err = extract_archive(download_path, extract_temp, path)
    if not extracted_binary then
      stderr_write("shimlink: failed to extract " .. binary_name .. ": " .. err)
      rm_rf(temp_dir)
      return false
    end
  else
    extracted_binary = download_path
    extract_temp = temp_dir
  end

  -- Make executable
  if file_exists(extracted_binary) then
    ffi.C.chmod(extracted_binary, tonumber("0755", 8))
  end

  -- Calculate actual checksum
  local actual_sha256 = calculate_sha256(extracted_binary)

  -- Handle checksum verification and updates
  if force then
    update_config_checksum(binary_name, config, actual_sha256)
    stderr_write("shimlink: force mode - updated checksum for " .. binary_name)
  elseif expected_sha256 then
    if actual_sha256 ~= expected_sha256 then
      stderr_write("shimlink: checksum mismatch for " .. binary_name)
      stderr_write("shimlink:   expected: " .. expected_sha256)
      stderr_write("shimlink:   actual:   " .. actual_sha256)
      rm_rf(temp_dir)
      return false
    end
  end

  -- Remove existing directory if it exists
  if is_directory(bin_dir) or file_exists(bin_dir) then
    rm_rf(bin_dir)
  end

  if path then
    -- Move the entire extracted directory structure
    os.execute(string.format("mv %q %q", extract_temp, bin_dir))
  else
    -- For direct binary downloads, create directory and move binary
    mkdir_p(bin_dir)
    local final_path = path_join(bin_dir, binary_name)
    os.execute(string.format("mv %q %q", extracted_binary, final_path))
  end

  stderr_write("shimlink: installed " .. binary_name)

  -- Create additional symlinks if configured
  local symlinks = binary_config.symlinks
  if symlinks then
    for src_path, dest_path in pairs(symlinks) do
      create_symlink(bin_dir, src_path, dest_path, binary_name)
    end
  end

  -- Clean up temp directory
  rm_rf(temp_dir)

  return true
end

-- Resolve alias
local function resolve_alias(name, config)
  local aliases = config.aliases or {}
  return aliases[name] or name
end

-- Get target name
local function get_target_name()
  local invoked_path = arg[0]
  local name = basename(invoked_path)

  if name == "shimlink.lua" or name == "shimlink" then
    return "shimlink"
  end

  return name
end

-- Execute binary
local function exec_binary(binary_name, args, config)
  local binary_config = config.binaries and config.binaries[binary_name]
  if not binary_config then
    stderr_write("shimlink: no configuration found for " .. binary_name)
    os.exit(1)
  end

  local bin_dir = get_bin_dir(binary_name)
  local path = binary_config.path
  local binary_path

  if path then
    binary_path = path_join(bin_dir, path)
  else
    binary_path = path_join(bin_dir, binary_name)
  end

  if not file_exists(binary_path) then
    stderr_write("shimlink: binary " .. binary_name .. " not found at " .. binary_path)
    os.exit(1)
  end

  -- Build argv array for execve
  local argv = ffi.new("char*[?]", #args + 2)
  argv[0] = ffi.cast("char*", binary_path)
  for i, arg_val in ipairs(args) do
    argv[i] = ffi.cast("char*", arg_val)
  end
  argv[#args + 1] = nil

  -- Use the environ global variable directly (works on Linux and macOS)
  -- execve expects char *const envp[], so we just pass environ
  local result = ffi.C.execve(binary_path, argv, ffi.C.environ)

  -- If execve returns, an error occurred
  stderr_write("shimlink: failed to exec " .. binary_path .. ": " .. tostring(result))
  os.exit(1)
end

-- Show help
local function show_help()
  print("shimlink: A symlink-based binary manager")
  print()
  print("Usage:")
  print("  shimlink                    # Show this help")
  print("  shimlink -f <binary>        # Force download and update checksum")
  print("  ln -s shimlink <binary>     # Create symlink for managed binary")
  print("  <binary> [args...]          # Execute binary through shimlink")
  print()
  print("Options:")
  print("  -f, --force                 # Skip checksum validation and update config")
  print()
  print("When invoked through a symlink, shimlink automatically downloads")
  print("and manages the target binary, then executes it with all arguments.")
  print()
  print("Aliases can be defined in the 'aliases' section of the config to map")
  print("alternative names to actual binary names (e.g., 'nvim-1' -> 'nvim').")
  print()
  print("Configuration: ~/.config/shimlink/<platform>.lua")
  print("Binaries stored: ~/.local/share/shimlink/<binary>/")
end

-- Main entry point
local function main()
  local target_name = get_target_name()

  if target_name == "shimlink" then
    -- Parse arguments when invoked as shimlink directly
    local force = false
    local binary = nil
    local show_help_flag = false

    local i = 1
    while i <= #arg do
      if arg[i] == "-f" or arg[i] == "--force" then
        force = true
        i = i + 1
      elseif arg[i] == "-h" or arg[i] == "--help" then
        show_help_flag = true
        i = i + 1
      else
        binary = arg[i]
        i = i + 1
      end
    end

    if show_help_flag or (not force and not binary) then
      show_help()
      os.exit(0)
    end

    if force then
      if not binary then
        stderr_write("shimlink: -f requires a binary name")
        os.exit(1)
      end

      -- Load configuration
      local ok, config = pcall(load_config)
      if not ok then
        stderr_write("shimlink: failed to load configuration: " .. tostring(config))
        os.exit(1)
      end

      -- Force download the specified binary
      if not download_binary(binary, config, true) then
        stderr_write("shimlink: failed to force download " .. binary)
        os.exit(1)
      end
      os.exit(0)
    end

    show_help()
    os.exit(0)
  end

  -- Load configuration
  local ok, config = pcall(load_config)
  if not ok then
    stderr_write("shimlink: failed to load configuration: " .. tostring(config))
    os.exit(1)
  end

  -- Resolve alias to actual binary name
  local actual_binary_name = resolve_alias(target_name, config)

  -- Check if we need to download the binary
  if needs_download(actual_binary_name, config) then
    if not download_binary(actual_binary_name, config, false) then
      stderr_write("shimlink: failed to ensure " .. actual_binary_name .. " is available")
      os.exit(1)
    end
  end

  -- Execute the target binary with all arguments
  local args = {}
  for i = 1, #arg do
    table.insert(args, arg[i])
  end
  exec_binary(actual_binary_name, args, config)
end

-- Run main
main()
