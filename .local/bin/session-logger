#!/usr/bin/env python3
# 🍺 session-logger
# https://wcm.is/sharing-claude-code-sessions
# https://gist.github.com/whilp/9f53e7651c20fe30e4b22c6bbf8f4f9b#file-session-logger

import json
import sys
import re
import difflib
import argparse
import subprocess
import os
from pathlib import Path
from typing import Dict, Any, List


def escape_backticks(content: str) -> str:
    """Escape triple backticks in content to prevent markdown breakage"""
    if not content:
        return content
    # Replace ``` with `​`` (using zero-width space U+200B)
    return content.replace("```", "`​``")


def format_code_block(content: str, language: str = "") -> str:
    """Format content as a code block, escaping any existing triple backticks"""
    escaped_content = escape_backticks(content)
    return f"```{language}\n{escaped_content}\n```"


def detect_language(file_path: str, content: str) -> str:
    """Detect programming language from file path and content"""
    import os
    import re

    # Get file extension
    _, ext = os.path.splitext(file_path.lower())

    # Extension-based detection
    ext_map = {
        ".py": "python",
        ".js": "javascript",
        ".jsx": "jsx",
        ".ts": "typescript",
        ".tsx": "tsx",
        ".rb": "ruby",
        ".go": "go",
        ".java": "java",
        ".c": "c",
        ".cpp": "cpp",
        ".cc": "cpp",
        ".cxx": "cpp",
        ".h": "c",
        ".hpp": "cpp",
        ".cs": "csharp",
        ".php": "php",
        ".swift": "swift",
        ".kt": "kotlin",
        ".scala": "scala",
        ".rs": "rust",
        ".sh": "bash",
        ".bash": "bash",
        ".zsh": "zsh",
        ".fish": "fish",
        ".ps1": "powershell",
        ".html": "html",
        ".htm": "html",
        ".xml": "xml",
        ".css": "css",
        ".scss": "scss",
        ".sass": "sass",
        ".less": "less",
        ".json": "json",
        ".yaml": "yaml",
        ".yml": "yaml",
        ".toml": "toml",
        ".ini": "ini",
        ".cfg": "ini",
        ".conf": "ini",
        ".md": "markdown",
        ".markdown": "markdown",
        ".rst": "rst",
        ".tex": "latex",
        ".sql": "sql",
        ".r": "r",
        ".R": "r",
        ".m": "matlab",
        ".pl": "perl",
        ".pm": "perl",
        ".lua": "lua",
        ".vim": "vim",
        ".dockerfile": "dockerfile",
        ".makefile": "makefile",
        ".mk": "make",
    }

    if ext in ext_map:
        return ext_map[ext]

    # Special filename-based detection
    filename = os.path.basename(file_path.lower())
    if filename in ["dockerfile", "containerfile"]:
        return "dockerfile"
    elif filename in ["makefile", "gnumakefile"]:
        return "makefile"
    elif filename in ["rakefile"]:
        return "ruby"
    elif filename in ["gemfile", "gemfile.lock"]:
        return "ruby"
    elif filename in ["package.json", "package-lock.json"]:
        return "json"
    elif filename in ["cargo.toml", "cargo.lock"]:
        return "toml"
    elif filename in ["requirements.txt", "setup.py", "pyproject.toml"]:
        return "python"

    # Content-based detection (shebang)
    if content.strip():
        first_line = content.split("\n")[0].strip()
        if first_line.startswith("#!"):
            shebang = first_line.lower()
            if "python" in shebang:
                return "python"
            elif "node" in shebang or "javascript" in shebang:
                return "javascript"
            elif "ruby" in shebang:
                return "ruby"
            elif "bash" in shebang or "/bin/sh" in shebang:
                return "bash"
            elif "zsh" in shebang:
                return "zsh"
            elif "fish" in shebang:
                return "fish"
            elif "perl" in shebang:
                return "perl"
            elif "php" in shebang:
                return "php"
            elif "lua" in shebang:
                return "lua"

        # Check for common patterns in first few lines
        first_few_lines = "\n".join(content.split("\n")[:5]).lower()
        if re.search(r"^\s*<\?xml", first_few_lines, re.MULTILINE):
            return "xml"
        elif re.search(r"^\s*<!doctype html|^\s*<html", first_few_lines, re.MULTILINE):
            return "html"
        elif re.search(r"^\s*#\s*[a-z0-9_-]+|^\s*##", first_few_lines, re.MULTILINE):
            return "markdown"

    # Default to plain text
    return ""


def format_tool_call_summary(
    tool_call: Dict[str, Any], tool_result_content: str = None
) -> str:
    """Format a tool call for summary display"""
    name = tool_call.get("name", "unknown")
    params = tool_call.get("input", {})

    # Create concise summaries
    if name == "Bash":
        command = params.get("command", "")
        description = params.get("description", "")
        # For Bash commands, use description in summary and put command in details
        if "\n" in command:
            # For multiline commands, show description in summary
            return f"{name}({description})" if description else f"{name}(...)"
        else:
            # For single-line commands, also use description
            return f"{name}({description})" if description else f"{name}({command})"
    elif name == "Read":
        file_path = params.get("file_path", "")
        return f"{name}({file_path})"
    elif name == "Edit":
        file_path = params.get("file_path", "")
        return f"{name}({file_path})"
    elif name == "Write":
        file_path = params.get("file_path", "")
        return f"{name}({file_path})"
    elif name == "Grep":
        pattern = params.get("pattern", "")
        return f"{name}({pattern})"
    elif name == "TodoWrite":
        todos = params.get("todos", [])
        if isinstance(todos, list) and len(todos) > 0:
            # Format todos as bullet points with status indicators
            todo_summaries = []
            for todo in todos[:3]:  # Show first 3 todos
                if isinstance(todo, dict):
                    content = todo.get("content", "")
                    status = todo.get("status", "pending")
                    if status == "completed":
                        todo_summaries.append(f"[x] {content}")
                    elif status == "in_progress":
                        todo_summaries.append(f"[ ] {content}")
                    else:
                        todo_summaries.append(f"[ ] {content}")

            if len(todos) > 3:
                todo_summaries.append(f"+ {len(todos) - 3} more")

            summary_lines = ["Update todos:"]
            summary_lines.append("")  # Empty line after header
            summary_lines.extend([f"- {s}" for s in todo_summaries])
            summary_lines.append("")  # Empty line at end
            return "\n".join(summary_lines)
        else:
            return f"{name}(...)"
    else:
        # Generic formatting
        if params:
            first_param = next(iter(params.values())) if params else ""
            if isinstance(first_param, str) and len(first_param) > 40:
                first_param = first_param[:40] + "..."
            elif isinstance(first_param, (list, dict)):
                first_param = "..."
            return f"{name}({first_param})"
        else:
            return f"{name}()"


def format_tool_call_details(
    tool_call: Dict[str, Any], tool_result_content: str = None
) -> str:
    """Format detailed tool call parameters"""
    name = tool_call.get("name", "unknown")
    params = tool_call.get("input", {})

    # For Read tool, show the actual file content if available
    if name == "Read" and tool_result_content:
        # Remove line number prefixes (format: '     1→')
        lines = tool_result_content.split("\n")
        cleaned_lines = []

        # Skip system-reminder sections
        skip_until_end = False
        for line in lines:
            # Check for system-reminder tags
            if "<system-reminder>" in line:
                skip_until_end = True
                continue
            elif "</system-reminder>" in line:
                skip_until_end = False
                continue
            elif skip_until_end:
                continue

            # Match pattern like '     1→' or '    10→' etc.
            import re

            # Remove line numbers that start with spaces, followed by digits, followed by →
            cleaned_line = re.sub(r"^\s*\d+→", "", line)
            cleaned_lines.append(cleaned_line)

        cleaned_content = "\n".join(cleaned_lines)

        # Detect language from file path or content
        file_path = params.get("file_path", "")
        language = detect_language(file_path, cleaned_content)

        # Return the content directly without additional code block wrapping
        # since it will be wrapped in the details block later
        return cleaned_content
    elif name == "Read":
        return "..."

    # For Edit tool, show diff-style format
    if name == "Edit":
        old_string = params.get("old_string", "")
        new_string = params.get("new_string", "")
        file_path = params.get("file_path", "")

        if old_string and new_string:
            # Create unified diff using difflib
            old_lines = old_string.splitlines(keepends=True)
            new_lines = new_string.splitlines(keepends=True)
            diff = difflib.unified_diff(
                old_lines, new_lines, fromfile="old", tofile="new", n=3
            )
            diff_text = "".join(diff)

            if diff_text:
                return f"```diff\n{escape_backticks(diff_text)}\n```"
            else:
                return "No changes"

    if not params:
        return f"{name}()"

    # Format parameters as JSON-like structure
    formatted_params = []
    for key, value in params.items():
        if isinstance(value, str):
            formatted_params.append(f'  {key}: "{value}"')
        elif isinstance(value, (list, dict)):
            # Pretty format complex structures
            import json

            formatted_value = json.dumps(value, indent=2).replace("\n", "\n  ")
            formatted_params.append(f"  {key}: {formatted_value}")
        else:
            formatted_params.append(f"  {key}: {value}")

    return f"{name}(\n{chr(10).join(formatted_params)}\n)"


def format_tool_result(result: Dict[str, Any]) -> str:
    """Format a tool result"""
    content = result.get("content", "")
    if isinstance(content, list):
        # Handle structured content
        formatted_parts = []
        for item in content:
            if isinstance(item, dict):
                if item.get("type") == "text":
                    formatted_parts.append(item.get("text", ""))
                else:
                    formatted_parts.append(str(item))
            else:
                formatted_parts.append(str(item))
        content = "\n".join(formatted_parts)

    # Truncate very long results
    if len(content) > 1000:
        content = content[:1000] + "..."

    return content


def process_session_entry(
    entry: Dict[str, Any], tool_results: Dict[str, str] = None
) -> str:
    """Process a single session entry into markdown"""
    if tool_results is None:
        tool_results = {}
    msg_type = entry.get("type", "unknown")
    message = entry.get("message", {})

    # Get toolUseResult metadata if available
    tool_use_result = entry.get("toolUseResult", {})

    # Handle summary entries
    if msg_type == "summary":
        summary_text = entry.get("summary", "")
        return f"# {summary_text}" if summary_text else ""

    if msg_type == "user":
        content = message.get("content", "")

        # Handle tool results that come as user messages
        if isinstance(content, list):
            # This is likely a tool result
            tool_results = []
            for item in content:
                if isinstance(item, dict) and item.get("type") == "tool_result":
                    tool_content = item.get("content", "")
                    if tool_content and tool_content.strip():
                        # Filter out system reminders, todo confirmations, and successful edit results
                        if (
                            "system-reminder" in tool_content.lower()
                            or "todos have been modified successfully"
                            in tool_content.lower()
                            or (
                                "has been updated" in tool_content.lower()
                                and "here's the result" in tool_content.lower()
                            )
                        ):
                            continue

                        # Wrap tool result in <details>
                        if any(
                            keyword in tool_content.lower()
                            for keyword in [
                                "function",
                                "class",
                                "def ",
                                "import ",
                                "local function",
                                "vim.",
                                "error:",
                                r"l \d+:",
                            ]
                        ):
                            formatted_content = format_code_block(tool_content)
                        else:
                            formatted_content = tool_content

                        # Create better summary using tool_use_result from entry level
                        if tool_use_result and isinstance(tool_use_result, dict):
                            # Check for structured data (like Grep results)
                            if "numLines" in tool_use_result:
                                # Grep-style result with numLines
                                num_lines = tool_use_result.get("numLines", 0)
                                num_files = tool_use_result.get("numFiles", 0)
                                mode = tool_use_result.get("mode", "")
                                filenames = tool_use_result.get("filenames", [])

                                # Build summary for Grep results
                                if num_files > 0:
                                    summary = (
                                        f"{num_lines} matches in {num_files} files"
                                    )
                                elif filenames:
                                    file_count = len(filenames)
                                    summary = (
                                        f"{num_lines} matches in {file_count} files"
                                    )
                                else:
                                    summary = f"{num_lines} matches"

                                tool_results.append(
                                    f"<details>\n<summary>{summary}</summary>\n\n{formatted_content}\n</details>"
                                )
                            elif (
                                "stdout" in tool_use_result
                                and "stderr" in tool_use_result
                            ):
                                # Bash-style result with stdout/stderr - create separate details blocks
                                stdout = tool_use_result.get("stdout", "")
                                stderr = tool_use_result.get("stderr", "")

                                stdout_lines = (
                                    len(
                                        [
                                            line
                                            for line in stdout.split("\n")
                                            if line.strip()
                                        ]
                                    )
                                    if stdout
                                    else 0
                                )
                                stderr_lines = (
                                    len(
                                        [
                                            line
                                            for line in stderr.split("\n")
                                            if line.strip()
                                        ]
                                    )
                                    if stderr
                                    else 0
                                )

                                # Always create stdout details block
                                stdout_summary = f"{stdout_lines} {'line' if stdout_lines == 1 else 'lines'} on stdout"
                                if stdout.strip():
                                    stdout_formatted = (
                                        f"```\n{escape_backticks(stdout)}\n```"
                                    )
                                else:
                                    stdout_formatted = "```\n(empty)\n```"
                                tool_results.append(
                                    f"<details>\n<summary>{stdout_summary}</summary>\n\n{stdout_formatted}\n</details>"
                                )

                                # Create stderr details block only if stderr has content
                                if stderr.strip():
                                    stderr_summary = f"{stderr_lines} {'line' if stderr_lines == 1 else 'lines'} on stderr"
                                    tool_results.append(
                                        f"<details>\n<summary>{stderr_summary}</summary>\n\n```\n{escape_backticks(stderr)}\n```\n</details>"
                                    )
                            else:
                                # Fallback to content analysis
                                lines = tool_content.split("\n")
                                line_count = len(
                                    [line for line in lines if line.strip()]
                                )
                                summary = f"{line_count} {'line' if line_count == 1 else 'lines'} on stdout, 0 lines on stderr"
                                tool_results.append(
                                    f"<details>\n<summary>{summary}</summary>\n\n{formatted_content}\n</details>"
                                )
                        else:
                            # No structured data, analyze content directly
                            lines = tool_content.split("\n")
                            line_count = len([line for line in lines if line.strip()])
                            summary = f"{line_count} {'line' if line_count == 1 else 'lines'} on stdout, 0 lines on stderr"
                            tool_results.append(
                                f"<details>\n<summary>{summary}</summary>\n\n{formatted_content}\n</details>"
                            )

            if tool_results:
                return "\n".join(tool_results)
            else:
                # Skip raw tool result arrays entirely - they're not useful in clean output
                return ""
        else:
            # Regular user message
            if content.startswith("<") and content.endswith(">"):
                # Skip system messages
                return ""
            if content == "(no content)":
                # Skip empty content messages
                return ""
            if content.startswith("Caveat:"):
                # Skip caveat messages entirely
                return ""
            return f"##### user\n\n● {content}"

    elif msg_type == "assistant":
        content = message.get("content", [])
        output_parts = ["##### assistant"]

        if isinstance(content, str):
            if content.strip():
                output_parts.append(f"● {content}")
        elif isinstance(content, list):
            text_content = ""
            tool_calls = []

            for item in content:
                if isinstance(item, dict):
                    if item.get("type") == "text":
                        text_content += item.get("text", "")
                    elif item.get("type") == "tool_use":
                        tool_calls.append(item)

            # Add newline after heading
            output_parts = ["##### assistant", ""]

            if text_content.strip():
                # Convert markdown headings to bold text
                content = text_content.strip()
                # Replace any markdown headings (# to #####) with bold formatting
                content = re.sub(
                    r"^(#{1,5}) (.+)$", r"**\1 \2**", content, flags=re.MULTILINE
                )
                output_parts.append(f"● {content}")

            # Wrap tool calls in details
            for tool_call in tool_calls:
                tool_use_id = tool_call.get("id")
                tool_result_content = (
                    tool_results.get(tool_use_id) if tool_use_id else None
                )
                tool_summary = format_tool_call_summary(tool_call, tool_result_content)
                tool_details = format_tool_call_details(tool_call, tool_result_content)

                # Format summary with proper newlines based on content
                if tool_summary.startswith("Update todos:"):
                    # For TodoWrite, put initial text right after <summary>
                    details_block = f"<details>\n<summary>{tool_summary}</summary>\n\n```javascript\n{escape_backticks(tool_details)}\n```\n</details>"
                elif tool_call.get("name") == "Bash":
                    # For Bash commands, put the command in a bash code block in details
                    command = tool_call.get("input", {}).get("command", "")
                    details_block = f"<details>\n<summary><code>{tool_summary}</code></summary>\n\n```bash\n{escape_backticks(command)}\n```\n</details>"
                elif tool_call.get("name") == "Edit":
                    # For Edit tool, the details already contain the diff in a code block
                    details_block = f"<details>\n<summary><code>{tool_summary}</code></summary>\n\n{tool_details}\n</details>"
                elif tool_call.get("name") == "Read":
                    # For Read tool, detect language and format as code block
                    file_path = tool_call.get("input", {}).get("file_path", "")
                    language = detect_language(file_path, tool_details)
                    details_block = f"<details>\n<summary><code>{tool_summary}</code></summary>\n\n```{language}\n{escape_backticks(tool_details)}\n```\n</details>"
                else:
                    # For all other tools, use javascript for the tool call syntax
                    details_block = f"<details>\n<summary><code>{tool_summary}</code></summary>\n\n```javascript\n{escape_backticks(tool_details)}\n```\n</details>"
                output_parts.append(details_block)

        return (
            "\n".join(output_parts)
            if len(output_parts) > 2
            else "##### assistant\n\n- [No content]"
        )

    return f"- [{msg_type}] {message.get('content', '')}"


def main():
    parser = argparse.ArgumentParser(
        description="Process Claude session logs",
        epilog="""
To enable the SessionStart hook, add the following to ~/.claude/settings.json:

  "hooks": {
    "SessionStart": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "command",
            "command": "session-logger --hook"
          }
        ]
      }
    ]
  },
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("filename", nargs="?", help="Input JSONL file (default: stdin)")
    parser.add_argument("--run-tests", action="store_true", help="Run unit tests")
    parser.add_argument("--hook", action="store_true", help="Run as Claude Code hook")
    parser.add_argument(
        "--gist", action="store_true", help="Create GitHub gist with rendered markdown"
    )
    parser.add_argument(
        "--description",
        help="Description for the gist (default: 'Claude Code Session Log')",
    )
    parser.add_argument(
        "--install-command",
        action="store_true",
        help="Print Claude Code slash command configuration",
    )

    args = parser.parse_args()

    if args.run_tests:
        return run_tests()

    if args.install_command:
        return print_install_command()

    if args.hook:
        return run_hook()

    if args.filename:
        with open(args.filename, "r") as f:
            content = f.read()
    else:
        content = sys.stdin.read()

    # Parse JSONL
    messages = []
    for line in content.strip().split("\n"):
        if line.strip():
            try:
                msg = json.loads(line)
                messages.append(msg)
            except json.JSONDecodeError:
                continue

    if not messages:
        print("No valid JSON messages found", file=sys.stderr)
        return 1

    # Accumulate session metadata
    session_metadata = {
        "input_tokens": 0,
        "output_tokens": 0,
        "cache_creation_input_tokens": 0,
        "cache_read_input_tokens": 0,
        "total_messages": len(messages),
        "user_messages": 0,
        "assistant_messages": 0,
        "tool_calls": 0,
        "tool_results": 0,
    }

    # Build tool result map and collect metadata
    tool_results = {}
    for entry in messages:
        entry_type = entry.get("type", "")

        # Count message types
        if entry_type == "user":
            session_metadata["user_messages"] += 1
        elif entry_type == "assistant":
            session_metadata["assistant_messages"] += 1

        # Extract token usage from message.usage
        message = entry.get("message", {})
        usage = message.get("usage", {})
        if usage:
            session_metadata["input_tokens"] += usage.get("input_tokens", 0)
            session_metadata["output_tokens"] += usage.get("output_tokens", 0)
            session_metadata["cache_creation_input_tokens"] += usage.get(
                "cache_creation_input_tokens", 0
            )
            session_metadata["cache_read_input_tokens"] += usage.get(
                "cache_read_input_tokens", 0
            )

        # Process tool results and count tool usage
        if entry_type == "user":
            message = entry.get("message", {})
            content = message.get("content", [])
            if isinstance(content, list):
                for item in content:
                    if isinstance(item, dict) and item.get("type") == "tool_result":
                        session_metadata["tool_results"] += 1
                        tool_use_id = item.get("tool_use_id")
                        tool_content = item.get("content", "")
                        if tool_use_id and tool_content:
                            tool_results[tool_use_id] = tool_content
        elif entry_type == "assistant":
            message = entry.get("message", {})
            content = message.get("content", [])
            if isinstance(content, list):
                for item in content:
                    if isinstance(item, dict) and item.get("type") == "tool_use":
                        session_metadata["tool_calls"] += 1

    # Generate markdown
    output_lines = []

    for entry in messages:
        formatted = process_session_entry(entry, tool_results)
        if formatted and formatted.strip():
            output_lines.append(formatted)
            output_lines.append("")  # Empty line between messages

    # Remove trailing empty line
    if output_lines and output_lines[-1] == "":
        output_lines.pop()

    # Add session metadata
    if any(
        session_metadata[key] > 0
        for key in [
            "input_tokens",
            "output_tokens",
            "cache_creation_input_tokens",
            "cache_read_input_tokens",
        ]
    ):
        output_lines.append("")
        output_lines.append("---")
        output_lines.append("")
        output_lines.append("<details>")
        output_lines.append("<summary>Session Metadata</summary>")
        output_lines.append("")
        output_lines.append("**## Messages**")
        output_lines.append(f"- **Total**: {session_metadata['total_messages']}")
        output_lines.append(f"- **User**: {session_metadata['user_messages']}")
        output_lines.append(
            f"- **Assistant**: {session_metadata['assistant_messages']}"
        )
        output_lines.append("")
        output_lines.append("**## Tool Usage**")
        output_lines.append(f"- **Tool Calls**: {session_metadata['tool_calls']}")
        output_lines.append(f"- **Tool Results**: {session_metadata['tool_results']}")
        output_lines.append("")
        output_lines.append("**## Token Usage**")
        output_lines.append(f"- **Input Tokens**: {session_metadata['input_tokens']:,}")
        output_lines.append(
            f"- **Output Tokens**: {session_metadata['output_tokens']:,}"
        )
        if session_metadata["cache_creation_input_tokens"] > 0:
            output_lines.append(
                f"- **Cache Creation Input Tokens**: {session_metadata['cache_creation_input_tokens']:,}"
            )
        if session_metadata["cache_read_input_tokens"] > 0:
            output_lines.append(
                f"- **Cache Read Input Tokens**: {session_metadata['cache_read_input_tokens']:,}"
            )
        total_tokens = (
            session_metadata["input_tokens"] + session_metadata["output_tokens"]
        )
        output_lines.append(f"- **Total Tokens**: {total_tokens:,}")
        output_lines.append("")
        output_lines.append("</details>")

    markdown_output = "\n".join(output_lines)

    if args.gist:
        description = args.description or "Claude Code Session Log"
        # Use original content string before it gets processed into messages
        if args.filename:
            with open(args.filename, "r") as f:
                original_content = f.read()
        else:
            original_content = content
        session_id = extract_session_id_from_jsonl(original_content)
        existing_gist_url = get_existing_gist_url(session_id) if session_id else None

        try:
            if existing_gist_url:
                # Edit existing gist
                result = subprocess.run(
                    [
                        "gh",
                        "gist",
                        "edit",
                        existing_gist_url,
                        "--filename",
                        "session-log.md",
                        "--desc",
                        description,
                    ],
                    input=markdown_output,
                    text=True,
                    capture_output=True,
                    check=True,
                )
                print(f"Gist updated: {existing_gist_url}")
                gist_url = existing_gist_url
            else:
                # Create new gist
                result = subprocess.run(
                    [
                        "gh",
                        "gist",
                        "create",
                        "--desc",
                        description,
                        "--filename",
                        "session-log.md",
                    ],
                    input=markdown_output,
                    text=True,
                    capture_output=True,
                    check=True,
                )
                gist_url = result.stdout.strip()
                print(f"Gist created: {gist_url}")

            # Save session information if we have a session ID
            if session_id:
                save_session_info(session_id, gist_url)

            return 0
        except subprocess.CalledProcessError as e:
            print(f"Error with gist: {e.stderr}", file=sys.stderr)
            return 1
        except FileNotFoundError:
            print(
                "Error: 'gh' command not found. Please install GitHub CLI.",
                file=sys.stderr,
            )
            return 1
    else:
        print(markdown_output)
        return 0


def extract_session_id_from_jsonl(content: str) -> str:
    """Extract session ID from JSONL content by reading sessionId from first object"""
    if not content:
        return None

    # Get the first line of JSONL
    lines = content.strip().split("\n")
    if not lines:
        return None

    first_line = lines[0].strip()
    if not first_line:
        return None

    try:
        # Parse the first JSON object
        first_obj = json.loads(first_line)
        # Look for sessionId key
        return first_obj.get("sessionId")
    except json.JSONDecodeError:
        return None


def get_existing_gist_url(session_id: str) -> str:
    """Get existing gist URL for session ID if it exists"""
    if not session_id:
        return None

    claude_dir = Path.home() / ".claude" / "session-logger"
    session_file = claude_dir / f"{session_id}.json"

    if not session_file.exists():
        return None

    try:
        with open(session_file, "r") as f:
            session_data = json.load(f)
            return session_data.get(session_id)
    except Exception:
        return None


def save_session_info(session_id: str, gist_url: str):
    """Save session information to ~/.claude/session-logger/<session>.json"""
    claude_dir = Path.home() / ".claude" / "session-logger"
    claude_dir.mkdir(parents=True, exist_ok=True)

    session_file = claude_dir / f"{session_id}.json"
    session_data = {session_id: gist_url}

    try:
        with open(session_file, "w") as f:
            json.dump(session_data, f, indent=2)
    except Exception as e:
        print(f"Warning: Could not save session info: {e}", file=sys.stderr)


def print_install_command():
    """Print Claude Code slash command configuration"""
    command_config = """---
allowed-tools: Bash(session-logger:*)
description: Export a Claude Code session using session-logger
---

# Gist the session

Run `session-logger` to export a Claude Code session to markdown format and share as a private GitHub gist.

## Usage

- The current transcript path should be obvious from context when the `session-logger --hook` `SessionStart` hook is enabled
- If the transcript path is not present, the user may need to add or fix their hook configuration
- `session-logger` takes a `--description` option that will be used as the description for the resulting gist

## Examples

``` bash
session-logger --gist --description "Setting up PostgreSQL" ~/.claude/projects/<project>/<session>.jsonl
```"""
    print(command_config)
    return 0


def run_hook():
    """Run as Claude Code hook"""
    try:
        # Read JSON input from stdin
        hook_input = json.loads(sys.stdin.read())

        session_id = hook_input.get("session_id", "unknown")
        transcript_path = hook_input.get("transcript_path", "unknown")
        hook_event_name = hook_input.get("hook_event_name", "unknown")

        # Create hook response
        response = {
            "hookSpecificOutput": {
                "hookEventName": hook_event_name,
                "additionalContext": f"the current claude code session ID is {session_id} and the transcript path is {transcript_path}.",
            }
        }

        # Output JSON response
        print(json.dumps(response))
        return 0

    except Exception as e:
        # If there's an error, output error response
        error_response = {
            "hookSpecificOutput": {
                "hookEventName": "unknown",
                "additionalContext": f"Error in session-logger hook: {str(e)}",
            }
        }
        print(json.dumps(error_response))
        return 1


def run_tests():
    """Run minimal unit tests for session-logger functions"""
    import unittest

    class TestSessionLogger(unittest.TestCase):
        def test_detect_language(self):
            # Python file
            self.assertEqual(
                detect_language("test.py", "#!/usr/bin/env python3"), "python"
            )
            self.assertEqual(detect_language("script.py", "import os"), "python")

            # JavaScript file
            self.assertEqual(detect_language("app.js", "const x = 1;"), "javascript")

            # Bash script
            self.assertEqual(detect_language("script.sh", "#!/bin/bash"), "bash")

            # JSON file
            self.assertEqual(
                detect_language("package.json", '{"name": "test"}'), "json"
            )

            # Unknown file
            self.assertEqual(detect_language("unknown.xyz", "some content"), "")

        def test_format_code_block(self):
            content = "print('hello')"
            expected = "```python\nprint('hello')\n```"
            self.assertEqual(format_code_block(content, "python"), expected)

            # No language specified
            expected_no_lang = "```\nprint('hello')\n```"
            self.assertEqual(format_code_block(content), expected_no_lang)

            # Test escaping of existing backticks
            content_with_backticks = "```bash\necho 'test'\n```"
            expected_escaped = "```python\n`​``bash\necho 'test'\n`​``\n```"
            self.assertEqual(
                format_code_block(content_with_backticks, "python"), expected_escaped
            )

        def test_format_tool_call_summary(self):
            # Bash command
            bash_call = {
                "name": "Bash",
                "input": {"command": "ls -la", "description": "List files"},
            }
            self.assertEqual(format_tool_call_summary(bash_call), "Bash(List files)")

            # Read command
            read_call = {"name": "Read", "input": {"file_path": "/path/to/file.py"}}
            self.assertEqual(
                format_tool_call_summary(read_call), "Read(/path/to/file.py)"
            )

            # TodoWrite command
            todo_call = {
                "name": "TodoWrite",
                "input": {
                    "todos": [
                        {"content": "Fix bug", "status": "completed"},
                        {"content": "Add tests", "status": "pending"},
                    ]
                },
            }
            result = format_tool_call_summary(todo_call)
            self.assertIn("Update todos:", result)
            self.assertIn("[x] Fix bug", result)
            self.assertIn("[ ] Add tests", result)

        def test_process_session_entry_user(self):
            # Simple user message
            user_entry = {"type": "user", "message": {"content": "Hello world"}}
            result = process_session_entry(user_entry)
            self.assertEqual(result, "##### user\n\n● Hello world")

            # Skip system messages
            system_entry = {
                "type": "user",
                "message": {"content": "<system-reminder>test</system-reminder>"},
            }
            result = process_session_entry(system_entry)
            self.assertEqual(result, "")

        def test_process_session_entry_assistant(self):
            # Assistant with text content
            assistant_entry = {
                "type": "assistant",
                "message": {
                    "content": [{"type": "text", "text": "I'll help you with that."}]
                },
            }
            result = process_session_entry(assistant_entry)
            self.assertIn("##### assistant", result)
            self.assertIn("● I'll help you with that.", result)

    # Run the tests
    suite = unittest.TestLoader().loadTestsFromTestCase(TestSessionLogger)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    return 0 if result.wasSuccessful() else 1


if __name__ == "__main__":
    sys.exit(main())
