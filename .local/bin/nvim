#!/usr/bin/env luajit

local home = os.getenv("HOME")
local nvim = home .. "/.local/bin/nvim-1"
local sock = home .. "/.config/nvim/nvim.sock"

-- Check for server management commands first
local server_commands = {cleanup = true, load = true, reload = true, restart = true, serve = true}
if arg[1] and server_commands[arg[1]] then
  -- Handle these later in the script
else
  -- Client mode: if NVIM_INVIM is set or NVIM_SERVER_MODE is not set
  local nvim_invim = os.getenv("NVIM_INVIM")
  local nvim_server_mode = os.getenv("NVIM_SERVER_MODE")

if nvim_invim ~= nil and nvim_invim ~= "" or nvim_server_mode == nil or nvim_server_mode == "" then
  -- Build command with arguments - use exec to avoid shell overhead
  local ffi = require("ffi")
  ffi.cdef([[
    int execv(const char *path, char *const argv[]);
  ]])

  -- Build argv array for execv
  local argv = ffi.new("char*[?]", #arg + 4)
  argv[0] = ffi.cast("char*", nvim)
  argv[1] = ffi.cast("char*", "--server")
  argv[2] = ffi.cast("char*", sock)
  for i = 1, #arg do
    argv[i + 2] = ffi.cast("char*", arg[i])
  end
  argv[#arg + 3] = nil -- NULL-terminate

  -- Replace current process with nvim
  ffi.C.execv(nvim, argv)

  -- If execvp returns, it failed
  os.exit(1)
end
end

-- Detect platform
local function get_platform()
  local handle = io.popen("uname -s")
  local result = handle:read("*a"):lower():gsub("%s+", "")
  handle:close()
  if result == "darwin" then
    return "darwin"
  else
    return "linux"
  end
end

-- Server mode: handle cleanup and serve commands
if arg[1] == "cleanup" then
  os.remove(sock)
  os.exit()
elseif arg[1] == "load" then
  local platform = get_platform()
  local cmd
  if platform == "darwin" then
    cmd = "launchctl load ~/Library/LaunchAgents/com.user.nvim.plist 2>/dev/null || true"
  else
    cmd = "systemctl --user daemon-reload && systemctl --user enable nvim.service"
  end
  os.exit(os.execute(cmd))
elseif arg[1] == "reload" then
  local platform = get_platform()
  local cmd
  if platform == "darwin" then
    cmd = "launchctl unload ~/Library/LaunchAgents/com.user.nvim.plist && launchctl load ~/Library/LaunchAgents/com.user.nvim.plist"
  else
    cmd = "systemctl --user daemon-reload"
  end
  os.exit(os.execute(cmd))
elseif arg[1] == "restart" then
  local platform = get_platform()
  local cmd
  if platform == "darwin" then
    cmd = "launchctl stop com.user.nvim && launchctl start com.user.nvim"
  else
    cmd = "systemctl --user restart nvim"
  end
  os.exit(os.execute(cmd))
elseif arg[1] == "serve" then
  -- Remove socket on exit
  local function cleanup()
    os.remove(sock)
  end

  -- Set up signal handlers
  local ffi = require("ffi")
  ffi.cdef([[
    typedef void (*sighandler_t)(int);
    sighandler_t signal(int signum, sighandler_t handler);
  ]])

  local SIG_IGN = ffi.cast("sighandler_t", 1)
  local SIGINT = 2
  local SIGTERM = 15

  -- Register cleanup on exit
  local function signal_handler()
    cleanup()
    os.exit(1)
  end

  ffi.C.signal(SIGINT, signal_handler)
  ffi.C.signal(SIGTERM, signal_handler)

  -- Execute nvim in headless mode
  local cmd = string.format("/bin/zsh -l -i -c 'exec %s --listen %s --headless'", nvim, sock)
  local status = os.execute(cmd)
  cleanup()
  os.exit(status)
end
