#!/usr/bin/env luajit

local ffi = require("ffi")

-- FFI declarations
ffi.cdef([[
  int execve(const char *path, char *const argv[], char *const envp[]);
  extern char **environ;
]])

local function stderr_write(msg)
  io.stderr:write(msg .. "\n")
  io.stderr:flush()
end

local function get_home_dir()
  return os.getenv("HOME") or os.getenv("USERPROFILE")
end

local function expand_path(path)
  if path:sub(1, 1) == "~" then
    return get_home_dir() .. path:sub(2)
  end
  return path
end

-- Collect GH environment variables
local function collect_gh_env_vars()
  local gh_vars = {
    "GH_TOKEN",
    "GITHUB_TOKEN",
    "GH_ENTERPRISE_TOKEN",
    "GITHUB_ENTERPRISE_TOKEN",
    "GH_HOST",
    "GH_REPO",
    "GH_EDITOR",
    "GH_BROWSER",
    "GH_DEBUG",
    "GH_PAGER",
  }

  local env = {}
  for _, var in ipairs(gh_vars) do
    local value = os.getenv(var)
    if value then
      env[var] = value
    end
  end

  return env
end

-- Generate env.lua content (flat table with string keys/values)
local function generate_env_lua(env)
  local parts = {
    "-- GitHub CLI environment configuration",
    "-- Auto-generated by gh wrapper",
    "",
    "return {",
  }

  for key, value in pairs(env) do
    table.insert(parts, string.format("  %s = %q,", key, value))
  end

  table.insert(parts, "}")

  return table.concat(parts, "\n")
end

-- Load configuration from ~/.config/gh/env.lua
local function load_env_config()
  local config_path = expand_path("~/.config/gh/env.lua")

  -- Check if config file exists
  local f = io.open(config_path, "r")
  if not f then
    -- Config file is optional, continue without it
    return {}
  end
  f:close()

  -- Load and execute the config file
  local func, err = loadfile(config_path)
  if not func then
    stderr_write("gh: warning: failed to load " .. config_path .. ": " .. tostring(err))
    return {}
  end

  local ok, config = pcall(func)
  if not ok then
    stderr_write("gh: warning: failed to execute " .. config_path .. ": " .. tostring(config))
    return {}
  end

  if type(config) ~= "table" then
    stderr_write("gh: warning: config must return a table, got " .. type(config))
    return {}
  end

  return config
end

-- Set environment variables from config
local function apply_env_config(config)
  for key, value in pairs(config) do
    if type(value) == "string" then
      -- Set environment variable
      os.setenv(key, value)
    end
  end
end

-- Dump mode: output env.lua to stdout
-- Note: with multi-host support, this now only dumps the first host
local function dump_mode()
  local gh_binary = expand_path("~/.local/share/shimlink/bin/gh")
  local env = {}

  -- Get token and host from gh auth status -a -t
  local status_handle = io.popen(gh_binary .. " auth status -a -t 2>&1")
  if status_handle then
    local status = status_handle:read("*a")
    status_handle:close()

    -- Parse all hosts and tokens, use first found
    local current_host = nil
    for line in status:gmatch("[^\n]+") do
      -- Check if this is a host line (no leading whitespace)
      if not line:match("^%s") then
        current_host = line
        if not env.GH_HOST and not current_host:match("not logged") then
          env.GH_HOST = current_host
        end
      elseif current_host then
        -- Check if this is a token line
        local tok = line:match("Token:%s+([^%s]+)")
        if tok and not env.GH_TOKEN then
          env.GH_TOKEN = tok
          break
        end
      end
    end
  end

  -- Also collect any additional env vars set in environment
  for key, value in pairs(collect_gh_env_vars()) do
    if not env[key] then
      env[key] = value
    end
  end

  -- If no GH vars are set, exit
  if next(env) == nil then
    os.exit(0)
  end

  local env_lua_content = generate_env_lua(env)
  io.write(env_lua_content)
  os.exit(0)
end

-- Sync mode: set up gh auth on remote host
-- This uses gh auth login to authenticate directly on the remote
local function sync_mode(hostname, gh_host)
  -- If no gh_host specified, default to github.com
  if not gh_host or gh_host == "" then
    gh_host = "github.com"
  end

  -- Get the token for the specified host
  local gh_binary = expand_path("~/.local/share/shimlink/bin/gh")
  local token = nil

  local status_handle = io.popen(gh_binary .. " auth status -a -t 2>&1")
  if status_handle then
    local status = status_handle:read("*a")
    status_handle:close()

    -- Parse all hosts and tokens
    local current_host = nil
    for line in status:gmatch("[^\n]+") do
      -- Check if this is a host line (no leading whitespace)
      if not line:match("^%s") then
        current_host = line
      elseif current_host then
        -- Check if this is a token line
        local tok = line:match("Token:%s+([^%s]+)")
        if tok and current_host == gh_host then
          token = tok
          break
        end
      end
    end
  end

  -- If no token found, exit silently
  if not token then
    os.exit(0)
  end

  -- Send gh auth login command to remote host
  local ssh_cmd = string.format(
    '/usr/bin/ssh %s "echo %s | gh auth login -p ssh -h %s --with-token 2>/dev/null"',
    hostname,
    token,
    gh_host
  )

  local success = os.execute(ssh_cmd)

  if not success then
    os.exit(1)
  end

  os.exit(0)
end

-- Main execution
local function main()
  -- Check for dump mode (used by ssh LocalCommand)
  if os.getenv("GH_DUMP_ENV") then
    dump_mode()
  end

  -- Check for sync mode (sync env to remote host)
  local sync_host = os.getenv("GH_SYNC_ENV")
  if sync_host then
    local gh_host = os.getenv("GH_SYNC_HOST")
    sync_mode(sync_host, gh_host)
  end

  -- Load and apply environment configuration
  local config = load_env_config()
  apply_env_config(config)

  -- Invoke shimlink gh binary
  local gh_binary = expand_path("~/.local/share/shimlink/bin/gh")

  -- Check if binary exists
  local f = io.open(gh_binary, "r")
  if not f then
    stderr_write("gh: shimlink binary not found at " .. gh_binary)
    os.exit(1)
  end
  f:close()

  -- Build argv array for execve
  local argv = ffi.new("char*[?]", #arg + 2)
  argv[0] = ffi.cast("char*", gh_binary)
  for i = 1, #arg do
    argv[i] = ffi.cast("char*", arg[i])
  end
  argv[#arg + 1] = nil

  -- Execute gh binary
  local result = ffi.C.execve(gh_binary, argv, ffi.C.environ)

  -- If execve returns, an error occurred
  stderr_write("gh: failed to exec " .. gh_binary .. ": " .. tostring(result))
  os.exit(1)
end

main()
