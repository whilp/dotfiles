#!/usr/bin/env luajit

local ffi = require("ffi")

-- FFI declarations
ffi.cdef([[
  int execve(const char *path, char *const argv[], char *const envp[]);
  extern char **environ;
]])

local function stderr_write(msg)
  io.stderr:write(msg .. "\n")
  io.stderr:flush()
end

local function get_home_dir()
  return os.getenv("HOME") or os.getenv("USERPROFILE")
end

local function expand_path(path)
  if path:sub(1, 1) == "~" then
    return get_home_dir() .. path:sub(2)
  end
  return path
end

-- Collect GH environment variables
local function collect_gh_env_vars()
  local gh_vars = {
    "GH_TOKEN",
    "GITHUB_TOKEN",
    "GH_ENTERPRISE_TOKEN",
    "GITHUB_ENTERPRISE_TOKEN",
    "GH_HOST",
    "GH_REPO",
    "GH_EDITOR",
    "GH_BROWSER",
    "GH_DEBUG",
    "GH_PAGER",
  }

  local env = {}
  for _, var in ipairs(gh_vars) do
    local value = os.getenv(var)
    if value then
      env[var] = value
    end
  end

  return env
end

-- Generate env.lua content (flat table with string keys/values)
local function generate_env_lua(env)
  local parts = {
    "-- GitHub CLI environment configuration",
    "-- Auto-generated by gh wrapper",
    "",
    "return {",
  }

  for key, value in pairs(env) do
    table.insert(parts, string.format("  %s = %q,", key, value))
  end

  table.insert(parts, "}")

  return table.concat(parts, "\n")
end

-- Dump mode: output env.lua to stdout
local function dump_mode()
  local env = collect_gh_env_vars()

  -- If no GH vars are set, exit
  if next(env) == nil then
    os.exit(0)
  end

  local env_lua_content = generate_env_lua(env)
  io.write(env_lua_content)
  os.exit(0)
end

-- Sync mode: sync env.lua to remote host via ssh
local function sync_mode(hostname)
  local env = collect_gh_env_vars()

  -- If no GH vars are set, exit
  if next(env) == nil then
    os.exit(0)
  end

  local env_lua_content = generate_env_lua(env)

  -- Pipe content to ssh
  local ssh_cmd = string.format(
    '/usr/bin/ssh %s "mkdir -p ~/.config/gh && cat > ~/.config/gh/env.lua"',
    hostname
  )

  local ssh = io.popen(ssh_cmd, "w")
  if not ssh then
    stderr_write("gh: failed to connect to " .. hostname)
    os.exit(1)
  end

  ssh:write(env_lua_content)
  local success = ssh:close()

  if not success then
    os.exit(1)
  end

  os.exit(0)
end

-- Load configuration from ~/.config/gh/env.lua
local function load_env_config()
  local config_path = expand_path("~/.config/gh/env.lua")

  -- Check if config file exists
  local f = io.open(config_path, "r")
  if not f then
    -- Config file is optional, continue without it
    return {}
  end
  f:close()

  -- Load and execute the config file
  local func, err = loadfile(config_path)
  if not func then
    stderr_write("gh: warning: failed to load " .. config_path .. ": " .. tostring(err))
    return {}
  end

  local ok, config = pcall(func)
  if not ok then
    stderr_write("gh: warning: failed to execute " .. config_path .. ": " .. tostring(config))
    return {}
  end

  if type(config) ~= "table" then
    stderr_write("gh: warning: config must return a table, got " .. type(config))
    return {}
  end

  return config
end

-- Set environment variables from config
local function apply_env_config(config)
  for key, value in pairs(config) do
    if type(value) == "string" then
      -- Set environment variable
      os.setenv(key, value)
    end
  end
end

-- Main execution
local function main()
  -- Check for dump mode (used by ssh LocalCommand)
  if os.getenv("GH_DUMP_ENV") then
    dump_mode()
  end

  -- Check for sync mode (sync env to remote host)
  local sync_host = os.getenv("GH_SYNC_ENV")
  if sync_host then
    sync_mode(sync_host)
  end

  -- Load and apply environment configuration
  local config = load_env_config()
  apply_env_config(config)

  -- Invoke shimlink gh binary
  local gh_binary = expand_path("~/.local/share/shimlink/bin/gh")

  -- Check if binary exists
  local f = io.open(gh_binary, "r")
  if not f then
    stderr_write("gh: shimlink binary not found at " .. gh_binary)
    os.exit(1)
  end
  f:close()

  -- Build argv array for execve
  local argv = ffi.new("char*[?]", #arg + 2)
  argv[0] = ffi.cast("char*", gh_binary)
  for i = 1, #arg do
    argv[i] = ffi.cast("char*", arg[i])
  end
  argv[#arg + 1] = nil

  -- Execute gh binary
  local result = ffi.C.execve(gh_binary, argv, ffi.C.environ)

  -- If execve returns, an error occurred
  stderr_write("gh: failed to exec " .. gh_binary .. ": " .. tostring(result))
  os.exit(1)
end

main()
