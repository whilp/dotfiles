#!/usr/bin/env python3
"""
scpaste - Transfer clipboard content to remote hosts via SSH control sockets.

Finds SSH control sockets associated with the current Alacritty window,
gets clipboard content in multiple formats, and transfers to remote hosts.
"""

import os
import sys
import subprocess
import datetime
import tempfile
from pathlib import Path
from typing import List, Dict, Optional, Set


def log(message: str):
    """Simple logging to /tmp/scpaste.log"""
    with open("/tmp/scpaste.log", "a") as f:
        timestamp = datetime.datetime.now().isoformat()
        f.write(f"[{timestamp}] {message}\n")


def get_process_table():
    """Get the complete process table once"""
    result = subprocess.run(
        ["ps", "-eo", "pid,ppid,comm"],
        capture_output=True,
        text=True,
        timeout=10,
        check=True,
    )

    process_table = {}
    for line in result.stdout.strip().split("\n")[1:]:  # Skip header
        parts = line.strip().split(None, 2)
        if len(parts) < 3:
            continue
        pid, ppid, comm = parts[0], parts[1], parts[2]
        process_table[pid] = {"pid": pid, "ppid": ppid, "comm": comm}

    return process_table


def trace_process_ancestry(pid, process_table):
    """Trace process ancestry using pre-loaded process table"""
    ancestry = []
    current_pid = str(pid)

    while current_pid != "1" and current_pid in process_table:
        process_info = process_table[current_pid]
        ancestry.append(process_info)
        current_pid = process_info["ppid"]

    return ancestry


def get_alacritty_pid_from_env():
    """Get current Alacritty PID from environment variable"""
    alacritty_socket = os.environ.get("ALACRITTY_SOCKET")
    if not alacritty_socket:
        return None

    result = subprocess.run(
        ["lsof", "-F", "pc", alacritty_socket],
        capture_output=True,
        text=True,
        timeout=5,
        check=True,
    )
    records = parse_lsof_fields(result.stdout)
    for record in records:
        if record.get("command") == "alacritty":
            return record.get("pid")

    return None


def find_alacritty_in_ancestry(ancestry):
    """Check if Alacritty is in the process ancestry"""
    for process in ancestry:
        if "alacritty" in process["comm"].lower():
            return process["pid"]
    return None


def parse_lsof_fields(output: str) -> List[Dict[str, str]]:
    """Parse lsof -F output into structured records."""
    records = []
    current_record = {}
    field_mapping = {"p": "pid", "c": "command", "n": "name", "t": "type"}

    for line in output.strip().split("\n"):
        if not line:
            continue

        field_type = line[0]
        field_value = line[1:]
        field_name = field_mapping.get(field_type)
        if field_name is None:
            continue

        if field_name == "pid":
            # New process record starts
            if current_record:
                records.append(current_record)
            current_record = {}
        current_record[field_name] = field_value

    # Don't forget the last record
    if current_record:
        records.append(current_record)

    return records


def process_ssh_socket(current_process, field_value, process_table):
    """Process an SSH socket entry and return socket path and process info"""
    # Check if this is an SSH process using a socket
    if not (
        current_process.get("command") == "ssh"
        and current_process.get("type") == "unix"
        and field_value.startswith("/")
        and not field_value.startswith("->")
    ):
        return None

    # Clean socket path (remove temporary suffixes)
    clean_socket_path = field_value
    if ".sock." in field_value:
        clean_socket_path = field_value.split(".sock.")[0] + ".sock"

    # Trace ancestry
    ancestry = trace_process_ancestry(current_process["pid"], process_table)
    alacritty_pid = find_alacritty_in_ancestry(ancestry)

    process_info = {
        "pid": current_process["pid"],
        "command": current_process["command"],
        "original_path": field_value,
        "type": current_process["type"],
        "ancestry": ancestry,
        "alacritty_pid": alacritty_pid,
        "is_master": "[mux]" in field_value,
    }

    return clean_socket_path, process_info


def get_socket_groups(process_table):
    """Build socket groups from lsof records"""
    result = subprocess.run(
        ["lsof", "-U", "-F", "pcnt"],
        capture_output=True,
        text=True,
        timeout=10,
        check=True,
    )
    records = parse_lsof_fields(result.stdout)
    socket_groups = {}

    for record in records:
        # Process each record that has a name field (socket path)
        if "name" in record:
            result = process_ssh_socket(record, record["name"], process_table)
            if result:
                clean_socket_path, process_info = result

                # Group by socket path
                if clean_socket_path not in socket_groups:
                    socket_groups[clean_socket_path] = {
                        "socket_path": clean_socket_path,
                        "processes": [],
                        "alacritty_pid": None,
                    }

                socket_groups[clean_socket_path]["processes"].append(process_info)

                # If any process has Alacritty ancestry, mark the whole group
                alacritty_pid = process_info["alacritty_pid"]
                if (
                    alacritty_pid
                    and not socket_groups[clean_socket_path]["alacritty_pid"]
                ):
                    socket_groups[clean_socket_path]["alacritty_pid"] = alacritty_pid

    return socket_groups


def get_controlpath_clients(process_table):
    """Find SSH client processes that use ControlPath and return client data by socket path"""
    ps_result = subprocess.run(
        ["ps", "-eo", "pid,command"],
        capture_output=True,
        text=True,
        timeout=10,
        check=True,
    )

    clients_by_socket = {}

    for line in ps_result.stdout.strip().split("\n")[1:]:  # Skip header
        parts = line.strip().split(None, 1)
        if len(parts) < 2:
            continue

        pid, command = parts[0], parts[1]

        # Look for SSH clients with ControlPath
        if not (
            ("/usr/bin/ssh" in command or command.startswith("ssh "))
            and "-o ControlPath=" in command
            and "[mux]" not in command
        ):
            continue

        # Extract ControlPath
        try:
            control_path = command.split("-o ControlPath=")[1].split()[0]
        except (IndexError, ValueError):
            continue

        # Get ancestry for this SSH client
        ancestry = trace_process_ancestry(pid, process_table)
        alacritty_pid = find_alacritty_in_ancestry(ancestry)

        # Create client info
        client_info = {
            "pid": pid,
            "command": "ssh-client",
            "original_path": f"client-using-{control_path}",
            "type": "client",
            "ancestry": ancestry,
            "alacritty_pid": alacritty_pid,
            "is_master": False,
        }

        # Group clients by their control path
        if control_path not in clients_by_socket:
            clients_by_socket[control_path] = []
        clients_by_socket[control_path].append(client_info)

    return clients_by_socket


def find_ssh_socket_groups():
    """Find SSH processes grouped by socket path"""
    process_table = get_process_table()
    socket_groups = get_socket_groups(process_table)
    clients_by_socket = get_controlpath_clients(process_table)

    # Merge client data into socket groups
    for socket_path, clients in clients_by_socket.items():
        if socket_path in socket_groups:
            socket_groups[socket_path]["processes"].extend(clients)

            # If any client has Alacritty ancestry, inherit it to the socket group
            for client in clients:
                alacritty_pid = client["alacritty_pid"]
                if alacritty_pid and not socket_groups[socket_path]["alacritty_pid"]:
                    socket_groups[socket_path]["alacritty_pid"] = alacritty_pid
                    socket_groups[socket_path]["alacritty_source"] = (
                        f"client-{client['pid']}"
                    )

    return socket_groups


def find_relevant_sockets(alacritty_pid: str) -> Dict[str, Dict]:
    """Find SSH sockets relevant to this Alacritty instance."""
    socket_groups = find_ssh_socket_groups()

    # Filter for groups that belong to the current Alacritty window
    relevant_sockets = {}
    for socket_path, group in socket_groups.items():
        if group.get("alacritty_pid") == alacritty_pid:
            # Test socket connectivity
            result = subprocess.run(
                ["ssh", "-S", socket_path, "-O", "check", "dummy"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            if result.returncode == 0:
                relevant_sockets[socket_path] = group

    return relevant_sockets


def get_clipboard_content() -> Dict[str, str]:
    """Get clipboard content in all available formats."""
    formats = {}

    # First, get clipboard info to see what formats are available
    try:
        info_result = subprocess.run(
            ["osascript", "-e", 'tell application "System Events" to clipboard info'],
            capture_output=True,
            text=True,
        )
        if info_result.returncode != 0:
            return {}
    except Exception:
        return {}

    clipboard_info = info_result.stdout.strip()

    # Try to get PNG data
    if "PNGf" in clipboard_info:
        try:
            png_result = subprocess.run(
                [
                    "osascript",
                    "-e",
                    'tell application "System Events" to get the clipboard as «class PNGf»',
                ],
                capture_output=True,
                text=True,
            )
            if png_result.returncode == 0 and png_result.stdout.strip():
                png_data = png_result.stdout.strip()
                # Parse PNG data: «data PNGf...hex...
                if png_data.startswith("«data PNGf") and png_data.endswith("»"):
                    hex_data = png_data[10:-1]  # Remove «data PNGf and »
                    formats["png"] = hex_data
        except Exception:
            pass

    # Try to get text data
    try:
        text_result = subprocess.run(["pbpaste"], capture_output=True, text=True)
        if text_result.returncode == 0 and text_result.stdout.strip():
            content = text_result.stdout.strip()
            formats["txt"] = content
    except Exception:
        pass

    return formats


def transfer_to_hosts(
    sockets: Dict[str, Dict], clipboard_content: Dict[str, str]
) -> List[str]:
    """Transfer clipboard content to remote hosts via SSH sockets."""
    if not clipboard_content:
        return []

    if not sockets:
        return []

    all_created_files = []

    for socket_path, group in sockets.items():
        # Test connection
        subprocess.run(
            ["ssh", "-S", socket_path, "-O", "check", "dummy"],
            check=True,
            capture_output=True,
        )

        created_files = []
        for ext, content in clipboard_content.items():
            if not content.strip():
                continue

            filename = f"~/paste.{ext}"

            # Create temporary file
            if ext == "png":
                mode, file_content = "wb", bytes.fromhex(content)
            else:
                mode, file_content = "w", content

            with tempfile.NamedTemporaryFile(
                mode=mode, suffix=f".{ext}", delete=False
            ) as temp_file:
                temp_file.write(file_content)
                temp_file_path = temp_file.name

            try:
                # Transfer via scp (SSH will determine host from control master)
                scp_cmd = [
                    "scp",
                    "-o",
                    f"ControlPath={socket_path}",
                    temp_file_path,
                    f"dummy:{filename}",
                ]
                subprocess.run(scp_cmd, capture_output=True, text=True, check=True)
                created_files.append(filename)
            finally:
                os.unlink(temp_file_path)

        if created_files:
            print(f"✅ Created {len(created_files)} files via {socket_path}:")
            for file in created_files:
                print(f"   📄 {file}")
            all_created_files.extend(created_files)

    return all_created_files


def main(environ: Dict[str, str], argv: List[str]) -> int:
    """Main function."""
    try:
        alacritty_pid = get_alacritty_pid_from_env()
        if not alacritty_pid:
            print("❌ Error: Not running in Alacritty or unable to detect PID")
            return 1

        # Find relevant SSH sockets
        sockets = find_relevant_sockets(alacritty_pid)
        if not sockets:
            print("❌ No SSH sockets found for this Alacritty window")
            return 1

        print(f"🔌 Found {len(sockets)} SSH socket groups:")
        for socket_path, group in sockets.items():
            process_count = len(group.get("processes", []))
            print(f"   • {socket_path} ({process_count} processes)")

        # Get clipboard content
        clipboard_content = get_clipboard_content()
        if not clipboard_content:
            print("❌ No clipboard content found")
            return 1

        print(f"📋 Found clipboard formats: {', '.join(clipboard_content.keys())}")

        # Transfer to remote hosts
        created_files = transfer_to_hosts(sockets, clipboard_content)

        if created_files:
            print(
                f"\n🎉 Successfully created {len(created_files)} files across {len(sockets)} hosts"
            )
        else:
            print("\n❌ No files were created")

        return 0

    except subprocess.CalledProcessError as e:
        print(f"❌ Command failed: {e.cmd[0]} (exit code {e.returncode})")
        if e.stderr:
            print(f"   Error: {e.stderr.strip()}")
        return 1
    except subprocess.TimeoutExpired as e:
        print(f"❌ Command timed out: {e.cmd[0]} (after {e.timeout}s)")
        return 1
    except Exception as e:
        print(f"❌ Unexpected error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main(os.environ, sys.argv))
