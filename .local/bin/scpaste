#!/usr/bin/env python3
"""
scpaste - Transfer clipboard content to remote hosts via SSH control sockets.

Finds SSH control sockets associated with the current terminal window,
gets clipboard content in multiple formats, and transfers to remote hosts.

Usage:
    scpaste [--terminal TERMINAL] [--verbose]

Options:
    --terminal TERMINAL    Terminal type (default: alacritty)
    --verbose              Enable verbose logging
"""

import argparse
import logging
import os
import sys
import subprocess
import datetime
import tempfile
import time
from pathlib import Path
from typing import List, Dict, Optional, Set


def configure_logging(verbose: bool) -> None:
    """Configure logging based on verbosity level."""
    if verbose:
        logging.basicConfig(
            level=logging.DEBUG,
            format="%(asctime)s - %(levelname)s - %(message)s",
            handlers=[
                logging.FileHandler("/tmp/scpaste.log"),
                logging.StreamHandler(sys.stderr),
            ],
        )
    else:
        # Silent by default - only log to file if it exists
        logging.basicConfig(
            level=logging.WARNING,
            format="%(asctime)s - %(levelname)s - %(message)s",
            handlers=[logging.NullHandler()],
        )


def get_process_table():
    """Get the complete process table once"""
    result = subprocess.run(
        ["ps", "-eo", "pid,ppid,comm"],
        capture_output=True,
        text=True,
        timeout=10,
        check=True,
    )

    process_table = {}
    for line in result.stdout.strip().split("\n")[1:]:  # Skip header
        parts = line.strip().split(None, 2)
        if len(parts) < 3:
            continue
        pid, ppid, comm = parts[0], parts[1], parts[2]
        process_table[pid] = {"pid": pid, "ppid": ppid, "comm": comm}

    return process_table


def trace_process_ancestry(pid, process_table):
    """Trace process ancestry using pre-loaded process table"""
    ancestry = []
    current_pid = str(pid)

    while current_pid != "1" and current_pid in process_table:
        process_info = process_table[current_pid]
        ancestry.append(process_info)
        current_pid = process_info["ppid"]

    return ancestry


def get_terminal_pid_from_env(terminal_type: str):
    """Get current terminal PID from environment variable"""
    terminal_socket = os.environ.get(f"{terminal_type.upper()}_SOCKET")
    if not terminal_socket:
        return None

    result = subprocess.run(
        ["lsof", "-F", "pc", terminal_socket],
        capture_output=True,
        text=True,
        timeout=5,
        check=True,
    )
    records = parse_lsof_fields(result.stdout)
    for record in records:
        if record.get("command") == terminal_type.lower():
            return record.get("pid")

    return None


def find_terminal_in_ancestry(ancestry, terminal_type: str):
    """Check if terminal is in the process ancestry"""
    for process in ancestry:
        if terminal_type.lower() in process["comm"].lower():
            return process["pid"]
    return None


def parse_lsof_fields(output: str) -> List[Dict[str, str]]:
    """Parse lsof -F output into structured records."""
    records = []
    current_record = {}
    field_mapping = {"p": "pid", "c": "command", "n": "name", "t": "type"}

    for line in output.strip().split("\n"):
        if not line:
            continue

        field_type = line[0]
        field_value = line[1:]
        field_name = field_mapping.get(field_type)
        if field_name is None:
            continue

        if field_name == "pid":
            # New process record starts
            if current_record:
                records.append(current_record)
            current_record = {}
        current_record[field_name] = field_value

    # Don't forget the last record
    if current_record:
        records.append(current_record)

    return records


def process_ssh_socket(current_process, field_value, process_table):
    """Process an SSH socket entry and return socket path and process info"""
    # Check if this is an SSH process using a socket
    if not (
        current_process.get("command") == "ssh"
        and current_process.get("type") == "unix"
        and field_value.startswith("/")
        and not field_value.startswith("->")
    ):
        return None

    # Clean socket path (remove temporary suffixes)
    clean_socket_path = field_value
    if ".sock." in field_value:
        clean_socket_path = field_value.split(".sock.")[0] + ".sock"

    # Trace ancestry
    ancestry = trace_process_ancestry(current_process["pid"], process_table)
    terminal_pid = None  # Will be set by caller

    process_info = {
        "pid": current_process["pid"],
        "command": current_process["command"],
        "original_path": field_value,
        "type": current_process["type"],
        "ancestry": ancestry,
        "terminal_pid": terminal_pid,
        "is_master": "[mux]" in field_value,
    }

    return clean_socket_path, process_info


def get_socket_groups(process_table, terminal_type: str):
    """Build socket groups from lsof records"""
    result = subprocess.run(
        ["lsof", "-U", "-F", "pcnt"],
        capture_output=True,
        text=True,
        timeout=10,
        check=True,
    )
    records = parse_lsof_fields(result.stdout)
    socket_groups = {}

    for record in records:
        # Process each record that has a name field (socket path)
        if "name" in record:
            result = process_ssh_socket(record, record["name"], process_table)
            if result:
                clean_socket_path, process_info = result

                # Set terminal_pid using terminal type
                process_info["terminal_pid"] = find_terminal_in_ancestry(
                    process_info["ancestry"], terminal_type
                )

                # Group by socket path
                if clean_socket_path not in socket_groups:
                    socket_groups[clean_socket_path] = {
                        "socket_path": clean_socket_path,
                        "processes": [],
                        "terminal_pid": None,
                    }

                socket_groups[clean_socket_path]["processes"].append(process_info)

                # If any process has terminal ancestry, mark the whole group
                terminal_pid = process_info["terminal_pid"]
                if (
                    terminal_pid
                    and not socket_groups[clean_socket_path]["terminal_pid"]
                ):
                    socket_groups[clean_socket_path]["terminal_pid"] = terminal_pid

    return socket_groups


def get_controlpath_clients(process_table, terminal_type: str):
    """Find SSH client processes that use ControlPath and return client data by socket path"""
    ps_result = subprocess.run(
        ["ps", "-eo", "pid,command"],
        capture_output=True,
        text=True,
        timeout=10,
        check=True,
    )

    clients_by_socket = {}

    for line in ps_result.stdout.strip().split("\n")[1:]:  # Skip header
        parts = line.strip().split(None, 1)
        if len(parts) < 2:
            continue

        pid, command = parts[0], parts[1]

        # Look for SSH clients with ControlPath
        if not (
            ("/usr/bin/ssh" in command or command.startswith("ssh "))
            and "-o ControlPath=" in command
            and "[mux]" not in command
        ):
            continue

        # Extract ControlPath
        try:
            control_path = command.split("-o ControlPath=")[1].split()[0]
        except (IndexError, ValueError):
            continue

        # Get ancestry for this SSH client
        ancestry = trace_process_ancestry(pid, process_table)
        terminal_pid = find_terminal_in_ancestry(ancestry, terminal_type)

        # Create client info
        client_info = {
            "pid": pid,
            "command": "ssh-client",
            "original_path": f"client-using-{control_path}",
            "type": "client",
            "ancestry": ancestry,
            "terminal_pid": terminal_pid,
            "is_master": False,
        }

        # Group clients by their control path
        if control_path not in clients_by_socket:
            clients_by_socket[control_path] = []
        clients_by_socket[control_path].append(client_info)

    return clients_by_socket


def find_ssh_socket_groups(terminal_type: str):
    """Find SSH processes grouped by socket path"""
    process_table = get_process_table()
    socket_groups = get_socket_groups(process_table, terminal_type)
    clients_by_socket = get_controlpath_clients(process_table, terminal_type)

    # Merge client data into socket groups
    for socket_path, clients in clients_by_socket.items():
        if socket_path in socket_groups:
            socket_groups[socket_path]["processes"].extend(clients)

            # If any client has terminal ancestry, inherit it to the socket group
            for client in clients:
                terminal_pid = client["terminal_pid"]
                if terminal_pid and not socket_groups[socket_path]["terminal_pid"]:
                    socket_groups[socket_path]["terminal_pid"] = terminal_pid
                    socket_groups[socket_path]["terminal_source"] = (
                        f"client-{client['pid']}"
                    )

    return socket_groups


def find_relevant_sockets(terminal_pid: str, terminal_type: str) -> Dict[str, Dict]:
    """Find SSH sockets relevant to this terminal instance."""
    socket_groups = find_ssh_socket_groups(terminal_type)

    # Filter for groups that belong to the current terminal window and are connectable
    relevant_sockets = {}
    for socket_path, group in socket_groups.items():
        if group.get("terminal_pid") == terminal_pid:
            # Test socket connectivity
            result = subprocess.run(
                ["ssh", "-S", socket_path, "-O", "check", "dummy"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            if result.returncode == 0:
                relevant_sockets[socket_path] = group

    return relevant_sockets


def get_clipboard_content() -> Dict[str, str]:
    """Get clipboard content in all available formats."""
    formats = {}

    # First, get clipboard info to see what formats are available
    try:
        info_result = subprocess.run(
            ["osascript", "-e", 'tell application "System Events" to clipboard info'],
            capture_output=True,
            text=True,
        )
        if info_result.returncode != 0:
            return {}
    except Exception:
        return {}

    clipboard_info = info_result.stdout.strip()

    # Try to get PNG data
    if "PNGf" in clipboard_info:
        try:
            png_result = subprocess.run(
                [
                    "osascript",
                    "-e",
                    'tell application "System Events" to get the clipboard as «class PNGf»',
                ],
                capture_output=True,
                text=True,
            )
            if png_result.returncode == 0 and png_result.stdout.strip():
                png_data = png_result.stdout.strip()
                # Parse PNG data: «data PNGf...hex...
                if png_data.startswith("«data PNGf") and png_data.endswith("»"):
                    hex_data = png_data[10:-1]  # Remove «data PNGf and »
                    formats["png"] = hex_data
        except Exception:
            pass

    # Try to get text data
    try:
        text_result = subprocess.run(["pbpaste"], capture_output=True, text=True)
        if text_result.returncode == 0 and text_result.stdout.strip():
            content = text_result.stdout.strip()
            formats["txt"] = content
    except Exception:
        pass

    return formats


def transfer_to_hosts(
    sockets: Dict[str, Dict], clipboard_content: Dict[str, str]
) -> List[str]:
    """Transfer clipboard content to remote hosts via SSH sockets."""
    if not clipboard_content:
        return []

    if not sockets:
        return []

    all_created_files = []

    for socket_path, group in sockets.items():
        # Test connection
        subprocess.run(
            ["ssh", "-S", socket_path, "-O", "check", "dummy"],
            check=True,
            capture_output=True,
        )

        created_files = []
        with tempfile.TemporaryDirectory() as temp_dir:
            for ext, content in clipboard_content.items():
                if not content.strip():
                    continue

                filename = f"~/paste.{ext}"
                temp_file_path = os.path.join(temp_dir, f"paste.{ext}")

                mode = "w"
                raw_content = content
                if ext == "png":
                    mode = "wb"
                    raw_content = bytes.fromhex(content)
                with open(temp_file_path, mode) as f:
                    f.write(raw_content)

                # Transfer via scp (SSH will determine host from control master)
                scp_cmd = [
                    "scp",
                    "-o",
                    f"ControlPath={socket_path}",
                    temp_file_path,
                    f"dummy:{filename}",
                ]
                subprocess.run(scp_cmd, capture_output=True, text=True, check=True)
                created_files.append(filename)

        if created_files:
            print(f"✅ Created {len(created_files)} files via {socket_path}:")
            for file in created_files:
                print(f"   📄 {file}")
            all_created_files.extend(created_files)

    return all_created_files


def parse_args(argv: List[str]) -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Transfer clipboard content to remote hosts via SSH control sockets"
    )
    parser.add_argument(
        "--terminal",
        "-t",
        default="alacritty",
        help="Terminal type (default: alacritty)",
    )
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Enable verbose logging",
    )
    return parser.parse_args(argv[1:])


def main(environ: Dict[str, str], argv: List[str]) -> int:
    """Main function."""
    args = parse_args(argv)
    configure_logging(args.verbose)
    terminal_type = args.terminal

    logging.debug(f"Starting scpaste with terminal type: {terminal_type}")

    terminal_pid = get_terminal_pid_from_env(terminal_type)
    if not terminal_pid:
        print(
            f"❌ Error: Not running in {terminal_type.title()} or unable to detect PID"
        )
        return 1

    # Find relevant SSH sockets
    all_sockets = find_relevant_sockets(terminal_pid, terminal_type)
    if not all_sockets:
        print(f"❌ No SSH sockets found for this {terminal_type.title()} window")
        return 1

    # Sort sockets by modification time (most recent first) and take only the first one
    socket_items = []
    for socket_path, group in all_sockets.items():
        try:
            mtime = os.path.getmtime(socket_path)
        except OSError:
            mtime = 0  # Fallback for sockets we can't stat
        socket_items.append((socket_path, group, mtime))

    socket_items.sort(key=lambda x: x[2], reverse=True)
    socket_path, group, _ = socket_items[0]
    sockets = {socket_path: group}

    process_count = len(group.get("processes", []))
    print(f"🔌 Using SSH socket: {socket_path} ({process_count} processes)")
    if len(all_sockets) > 1:
        print(f"   (Selected most recent from {len(all_sockets)} available sockets)")

    # Get clipboard content
    clipboard_content = get_clipboard_content()
    if not clipboard_content:
        print("❌ No clipboard content found")
        return 1

    print(f"📋 Found clipboard formats: {', '.join(clipboard_content.keys())}")

    # Transfer to remote hosts
    created_files = transfer_to_hosts(sockets, clipboard_content)

    if created_files:
        print(
            f"\n🎉 Successfully created {len(created_files)} files across {len(sockets)} hosts"
        )
    else:
        print("\n❌ No files were created")

    return 0


def outer(environ: Dict[str, str], argv: List[str]) -> int:
    try:
        return main(environ, argv)
    except subprocess.CalledProcessError as e:
        print(f"❌ Command failed: {e.cmd[0]} (exit code {e.returncode})")
        if e.stderr:
            print(f"   Error: {e.stderr.strip()}")
        return 1
    except subprocess.TimeoutExpired as e:
        print(f"❌ Command timed out: {e.cmd[0]} (after {e.timeout}s)")
        return 1
    except Exception as e:
        print(f"❌ Unexpected error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(outer(os.environ, sys.argv))
