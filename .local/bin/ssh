#!/usr/bin/env luajit

local ffi = require("ffi")

-- FFI declarations
ffi.cdef([[
  int execve(const char *path, char *const argv[], char *const envp[]);
  extern char **environ;
]])

local function stderr_write(msg)
  io.stderr:write(msg .. "\n")
  io.stderr:flush()
end

local function get_home_dir()
  return os.getenv("HOME") or os.getenv("USERPROFILE")
end

local function expand_path(path)
  if path:sub(1, 1) == "~" then
    return get_home_dir() .. path:sub(2)
  end
  return path
end

-- Collect GH environment variables
local function collect_gh_env_vars()
  local gh_vars = {
    "GH_TOKEN",
    "GITHUB_TOKEN",
    "GH_ENTERPRISE_TOKEN",
    "GITHUB_ENTERPRISE_TOKEN",
    "GH_HOST",
    "GH_REPO",
    "GH_EDITOR",
    "GH_BROWSER",
    "GH_DEBUG",
    "GH_PAGER",
  }

  local env = {}
  for _, var in ipairs(gh_vars) do
    local value = os.getenv(var)
    if value then
      env[var] = value
    end
  end

  return env
end

-- Generate env.lua content (flat table with string keys/values)
local function generate_env_lua(env)
  local parts = {
    "-- GitHub CLI environment configuration",
    "-- Auto-generated by ssh wrapper",
    "",
    "return {",
  }

  for key, value in pairs(env) do
    table.insert(parts, string.format("  %s = %q,", key, value))
  end

  table.insert(parts, "}")

  return table.concat(parts, "\n")
end

-- Parse ssh arguments to find hostname and detect if it's an interactive session
local function parse_ssh_args(args)
  local i = 1
  local hostname = nil
  local has_command = false

  while i <= #args do
    local arg = args[i]

    -- Skip flags that take arguments
    if arg == "-b" or arg == "-c" or arg == "-D" or arg == "-E" or arg == "-e" or
       arg == "-F" or arg == "-I" or arg == "-i" or arg == "-J" or arg == "-L" or
       arg == "-l" or arg == "-m" or arg == "-O" or arg == "-o" or arg == "-p" or
       arg == "-Q" or arg == "-R" or arg == "-S" or arg == "-W" or arg == "-w" then
      i = i + 2
    -- First non-flag argument is the hostname
    elseif not arg:match("^%-") then
      if not hostname then
        hostname = arg
      else
        -- Any argument after hostname is a command
        has_command = true
        break
      end
      i = i + 1
    else
      i = i + 1
    end
  end

  return hostname, not has_command
end

-- Sync GH environment to remote host
local function sync_gh_env(hostname)
  local env = collect_gh_env_vars()

  -- If no GH vars are set, skip sync
  if next(env) == nil then
    return true
  end

  local env_lua_content = generate_env_lua(env)

  -- Use ssh to write the file remotely
  local ssh_cmd = string.format(
    "/usr/bin/ssh %s 'mkdir -p ~/.config/gh && cat > ~/.config/gh/env.lua'",
    hostname
  )

  local handle = io.popen(ssh_cmd, "w")
  if not handle then
    stderr_write("ssh: warning: failed to sync GH environment to remote")
    return false
  end

  handle:write(env_lua_content)
  local success = handle:close()

  return success
end

-- Main execution
local function main()
  local ssh_binary = "/usr/bin/ssh"

  -- Collect arguments
  local args = {}
  for i = 1, #arg do
    table.insert(args, arg[i])
  end

  -- Parse arguments to determine if we should sync
  local hostname, is_interactive = parse_ssh_args(args)

  -- Sync GH environment for interactive sessions
  if is_interactive and hostname then
    sync_gh_env(hostname)
  end

  -- Build argv array for execve
  local argv = ffi.new("char*[?]", #args + 2)
  argv[0] = ffi.cast("char*", ssh_binary)
  for i = 1, #args do
    argv[i] = ffi.cast("char*", args[i])
  end
  argv[#args + 1] = nil

  -- Execute ssh binary
  local result = ffi.C.execve(ssh_binary, argv, ffi.C.environ)

  -- If execve returns, an error occurred
  stderr_write("ssh: failed to exec " .. ssh_binary .. ": " .. tostring(result))
  os.exit(1)
end

main()
