#!/usr/bin/env luajit

local ffi = require("ffi")

-- FFI declarations
ffi.cdef([[
  int execve(const char *path, char *const argv[], char *const envp[]);
  extern char **environ;
]])

local function stderr_write(msg)
  io.stderr:write(msg .. "\n")
  io.stderr:flush()
end

local function get_home_dir()
  return os.getenv("HOME") or os.getenv("USERPROFILE")
end

local function expand_path(path)
  if path:sub(1, 1) == "~" then
    return get_home_dir() .. path:sub(2)
  end
  return path
end

-- Collect GH environment variables
local function collect_gh_env_vars()
  local gh_vars = {
    "GH_TOKEN",
    "GITHUB_TOKEN",
    "GH_ENTERPRISE_TOKEN",
    "GITHUB_ENTERPRISE_TOKEN",
    "GH_HOST",
    "GH_REPO",
    "GH_EDITOR",
    "GH_BROWSER",
    "GH_DEBUG",
    "GH_PAGER",
  }

  local env = {}
  for _, var in ipairs(gh_vars) do
    local value = os.getenv(var)
    if value then
      env[var] = value
    end
  end

  return env
end

-- Generate env.lua content (flat table with string keys/values)
local function generate_env_lua(env)
  local parts = {
    "-- GitHub CLI environment configuration",
    "-- Auto-generated by ssh wrapper",
    "",
    "return {",
  }

  for key, value in pairs(env) do
    table.insert(parts, string.format("  %s = %q,", key, value))
  end

  table.insert(parts, "}")

  return table.concat(parts, "\n")
end

-- Sync GH environment to remote host
local function sync_gh_env(args)
  local env = collect_gh_env_vars()

  -- If no GH vars are set, skip sync
  if next(env) == nil then
    return
  end

  local env_lua_content = generate_env_lua(env)

  -- Build ssh command with same args, running remote command to write config
  local ssh_cmd = {"/usr/bin/ssh"}
  for i = 1, #args do
    table.insert(ssh_cmd, args[i])
  end
  table.insert(ssh_cmd, "mkdir -p ~/.config/gh && cat > ~/.config/gh/env.lua")

  local handle = io.popen(table.concat(ssh_cmd, " "), "w")
  if not handle then
    stderr_write("ssh: warning: failed to sync GH environment to remote")
    return
  end

  handle:write(env_lua_content)
  handle:close()
end

-- Main execution
local function main()
  local ssh_binary = "/usr/bin/ssh"

  -- Collect arguments
  local args = {}
  for i = 1, #arg do
    table.insert(args, arg[i])
  end

  -- Sync GH environment before connecting
  sync_gh_env(args)

  -- Build argv array for execve
  local argv = ffi.new("char*[?]", #args + 2)
  argv[0] = ffi.cast("char*", ssh_binary)
  for i = 1, #args do
    argv[i] = ffi.cast("char*", args[i])
  end
  argv[#args + 1] = nil

  -- Execute ssh binary
  local result = ffi.C.execve(ssh_binary, argv, ffi.C.environ)

  -- If execve returns, an error occurred
  stderr_write("ssh: failed to exec " .. ssh_binary .. ": " .. tostring(result))
  os.exit(1)
end

main()
